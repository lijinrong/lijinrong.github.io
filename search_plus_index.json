{"./":{"url":"./","title":"前言","keywords":"","body":"介绍 这是个人学习整理的学习笔记，方便以后查看 "},"技术笔记/缓存策略.html":{"url":"技术笔记/缓存策略.html","title":"缓存策略","keywords":"","body":"缓存策略 强缓存 Cache-control: 相对时间 public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 expire: 绝对时间 Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？ 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。 协商缓存 etag&&if-none-matched Last-modify&&if-modify-since 强缓存优先级: cache-control>expire 协商缓存: 如果有etag，last-modify就会被忽略 优先级：强缓存>协商缓存 "},"技术笔记/跨标签页通信.html":{"url":"技术笔记/跨标签页通信.html","title":"跨标签页通信","keywords":"","body":"跨页面通信 [TOC] 同源页面之间的通信 广播模式 1、BroadCast Channel BroadCast Channel 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的API和用法都非常简单。 下面的方式就可以创建一个标识为AlienZHOU的频道： const bc = new BroadcastChannel('AlienZHOU'); // 标识一致的页面都能收到广播消息 各个页面可以通过onmessage来监听被广播的消息： bc.onmessage = function (e) { const data = e.data; const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[BroadcastChannel] receive message:', text); }; 要发送消息时只需要调用实例上的postMessage方法即可： bc.postMessage(mydata); // myData为onmessage里面的e.data 取消当前页面的广播监听： 一种方式是取消或者修改相应的'message'事件监听 另一种简单的方式就是使用 Broadcast Channel 实例为我们提供的close方法。 bc.close(); 两者是有区别的： 取消'message'监听只是让页面不对广播消息进行响应，Broadcast Channel 仍然存在；而调用close方法这会切断与 Broadcast Channel 的连接，浏览器才能够尝试回收该对象，因为此时浏览器才会知道用户已经不需要使用广播频道了。 2、Service Worker Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。 Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章【PWA学习与实践】(3) 让你的WebApp离线可用。 首先在根目录创建sw.js，至于为什么要在根目录创建，是因为Service Worker默认的scope参数（可控制内容目录）为当前js的目录，且只能设置该目录的目录，若要控制更上层的目录，必须要返回Service-Worker-Allowed头，参考：【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案 /* ../sw.js Service Worker 逻辑 */ self.addEventListener('message', function (e) { console.log('service worker receive message', e.data); e.waitUntil( self.clients.matchAll().then(function (clients) { if (!clients || clients.length === 0) { return; } clients.forEach(function (client) { client.postMessage(e.data); }); }) ); }); 然后在页面注册Service Worker： /* 页面逻辑 */ navigator.serviceWorker.register('../sw.js').then(function () { console.log('Service Worker 注册成功'); }); 处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息： /* 页面逻辑 */ navigator.serviceWorker.addEventListener('message', function (e) { const data = e.data; const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[Service Worker] receive message:', text); }); 最后，当需要同步消息时，可以调用 Service Worker 的postMessage方法： /* 页面逻辑 */ navigator.serviceWorker.controller.postMessage(mydata); 我们在 Service Worker 中监听了message事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过self.clients.matchAll()获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的postMessage方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。 3、LocalStorage LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但StorageEvent这个与它相关的事件有些同学可能会比较陌生。 当 LocalStorage 变化时，会触发storage事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听storage事件即可收到通知。 window.addEventListener('storage', function (e) { if (e.key === 'ctc-msg') { const data = JSON.parse(e.newValue); const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[Storage I] receive message:', text); } }); 在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的setItem方法即可： mydata.st = +(new Date); window.localStorage.setItem('ctc-msg', JSON.stringify(mydata)); 注意，这里有一个细节：我们在mydata上添加了一个取当前毫秒时间戳的.st属性。这是因为，storage事件只有在值真正改变时才会触发。举个例子： window.localStorage.setItem('test', '123'); window.localStorage.setItem('test', '123'); 由于第二次的值'123'与第一次的值相同，所以以上的代码只会在第一次setItem时触发storage事件。因此我们通过设置st来保证每次调用时一定会触发storage事件。 共享存储-轮询模式 1、Shared Worker Shared Worker 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。 Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下： 让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过postMessage传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下： 首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单： // 构造函数的第二个参数是 Shared Worker 名称，也可以留空 const sharedWorker = new SharedWorker('../util.shared.js', 'ctc'); 然后，在该 Shared Worker 中支持 get 与 post 形式的消息： /* ../util.shared.js: Shared Worker 代码 */ let data = null; self.addEventListener('connect', function (e) { const port = e.ports[0]; port.addEventListener('message', function (event) { // get 指令则返回存储的消息数据 if (event.data.get) { data && port.postMessage(data); } // 非 get 指令则存储该消息数据 else { data = event.data; } }); port.start(); }); 之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息： // 定时轮询，发送 get 指令的消息 setInterval(function () { sharedWorker.port.postMessage({get: true}); }, 1000); // 监听 get 消息的返回数据 sharedWorker.port.addEventListener('message', (e) => { const data = e.data; const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[Shared Worker] receive message:', text); }, false); sharedWorker.port.start(); 最后，当要跨页面通信时，只需给 Shared Worker postMessage即可： sharedWorker.port.postMessage(mydata); 注意，如果使用addEventListener来添加 Shared Worker 的消息监听，需要显式调用MessagePort.start方法，即上文中的sharedWorker.port.start()；如果使用onmessage绑定监听则不需要。 2、IndexedDB 除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 IndexedDB 或 cookie。 鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。 其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。 打开数据库连接： function openStore() { const storeName = 'ctc_aleinzhou'; return new Promise(function (resolve, reject) { if (!('indexedDB' in window)) { return reject('don\\'t support indexedDB'); } const request = indexedDB.open('CTC_DB', 1); request.onerror = reject; request.onsuccess = e => resolve(e.target.result); request.onupgradeneeded = function (e) { const db = e.srcElement.result; if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) { const store = db.createObjectStore(storeName, {keyPath: 'tag'}); store.createIndex(storeName + 'Index', 'tag', {unique: false}); } } }); } 存储数据 function saveData(db, data) { return new Promise(function (resolve, reject) { const STORE_NAME = 'ctc_aleinzhou'; const tx = db.transaction(STORE_NAME, 'readwrite'); const store = tx.objectStore(STORE_NAME); const request = store.put({tag: 'ctc_data', data}); request.onsuccess = () => resolve(db); request.onerror = reject; }); } 查询/读取数据 function query(db) { const STORE_NAME = 'ctc_aleinzhou'; return new Promise(function (resolve, reject) { try { const tx = db.transaction(STORE_NAME, 'readonly'); const store = tx.objectStore(STORE_NAME); const dbRequest = store.get('ctc_data'); dbRequest.onsuccess = e => resolve(e.target.result); dbRequest.onerror = reject; } catch (err) { reject(err); } }); } 剩下的工作就非常简单了。首先打开数据连接，并初始化数据： openStore().then(db => saveData(db, null)) 对于消息读取，可以在连接与初始化后轮询： openStore().then(db => saveData(db, null)).then(function (db) { setInterval(function () { query(db).then(function (res) { if (!res || !res.data) { return; } const data = res.data; const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[Storage I] receive message:', text); }); }, 1000); }); 最后，要发送消息时，只需向 IndexedDB 存储数据即可： openStore().then(db => saveData(db, null)).then(function (db) { // …… 省略上面的轮询代码 // 触发 saveData 的方法可以放在用户操作的事件监听内 saveData(db, mydata); }); 小技巧: 在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有广播模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。 例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听visibilitychange这样的事件，来做一次信息同步即可。 下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。 口口相传模式 当我们使用window.open打开页面时，方法会返回一个被打开页面window的引用。而在未显示指定noopener时，被打开的页面可以通过window.opener获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。 首先，我们把window.open打开的页面的window对象收集起来： let childWins = []; document.getElementById('btn').addEventListener('click', function () { const win = window.open('./some/sample'); childWins.push(win); }); 然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面： // 过滤掉已经关闭的窗口 childWins = childWins.filter(w => !w.closed); if (childWins.length > 0) { mydata.fromOpenner = false; childWins.forEach(w => w.postMessage(mydata)); } if (window.opener && !window.opener.closed) { mydata.fromOpenner = true; window.opener.postMessage(mydata); } 注意，我这里先用.closed属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。 此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）: 需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化） window.addEventListener('message', function (e) { const data = e.data; const text = '[receive] ' + data.msg + ' —— tab ' + data.from; console.log('[Cross-document Messaging] receive message:', text); // 避免消息回传 if (window.opener && !window.opener.closed && data.fromOpenner) { window.opener.postMessage(data); } // 过滤掉已经关闭的窗口 childWins = childWins.filter(w => !w.closed); // 避免消息回传 if (childWins && !data.fromOpenner) { childWins.forEach(w => w.postMessage(data)); } }); 这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。 小憩一下 显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的window.open打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。 除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。 关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》 在线演示的 Demo >> 非同源页面之间的通信 上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？ 要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定origin来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：http://sample.com/bridge.html），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。 页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理 /* 业务页面代码 */ window.addEventListener('message', function (e) { // …… do something }); 然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息： /* 业务页面代码 */ window.frames[0].window.postMessage(mydata, '*'); 其中为了简便此处将postMessage的第二个参数设为了'*'，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel： /* iframe 内代码 */ const bc = new BroadcastChannel('AlienZHOU'); // 收到来自页面的消息后，在 iframe 间进行广播 window.addEventListener('message', function (e) { bc.postMessage(e.data); }); 其他 iframe 收到通知后，则会将该消息同步给所属的页面： /* iframe 内代码 */ // 对于收到的（iframe）广播消息，通知给所属的业务页面 bc.onmessage = function (e) { window.parent.postMessage(e.data, '*'); }; 下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。 其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。 总结 今天和大家分享了一下跨页面通信的各种方式。 对于同源页面，常见的方式包括： 广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent 共享存储模式：Shared Worker / IndexedDB / cookie 口口相传模式：window.open + window.opener 基于服务端：Websocket / Comet / SSE 等 而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。 "},"技术笔记/前端路由的两种模式：hash模式和 history模式.html":{"url":"技术笔记/前端路由的两种模式：hash模式和 history模式.html","title":"前端路由的两种模式：hash模式和 history模式","keywords":"","body":"前端路由的两种模式：hash模式和 history模式 为什么要使用路由 现在的网络应用程序越来越多的使用AJAX异步请求完成页面的无缝刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而破坏了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。 单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。 前端路由实现方式 路由需要实现三个功能： 当浏览器地址变化时，切换页面； 点击浏览器【后退】、【前进】按钮，网页内容跟随变化； 刷新浏览器，网页加载当前路由对应内容； 在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式： hash模式：监听浏览器地址hash值变化，执行相应的js切换网页； history模式：利用history API实现url地址改变，网页内容改变； 它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。 hash模式 使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点： hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如http://localhost/index.html#abc，这里的#abc就是hash； 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面； 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值； location.hash值的变化会直接反应到浏览器地址栏； 触发hashchange事件的几种情况： 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件； 当浏览器地址栏中URL包含哈希如 http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件； 当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件； html中标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件； //设置 url 的 hash，会在当前url后加上'#abc' window.location.hash='abc'; let hash = window.location.hash //'#abc' window.addEventListener('hashchange',function(){ //监听hash变化，点击浏览器的前进后退会触发 }) history模式 概述 window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。 属性 History 对象主要有两个属性。 History.length：当前窗口访问过的网址数量（包括当前网页） History.state：History 堆栈最上层的状态值（详见下文） // 当前窗口访问过多少个网页 history.length // 1 // History 对象的当前状态 // 通常是 undefined，即未设置 history.state // undefined 方法 History.back()、History.forward()、History.go() 这三个方法用于在历史之中移动。 History.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。 History.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。 History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。 history.back(); history.forward(); history.go(1);//相当于history.forward() history.go(-1);//相当于history.back() history.go(0); // 刷新当前页面 注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。 History.pushState() 该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。 语法：history.pushState(object, title, url) 该方法接受三个参数，依次为： object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。 title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。 url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。 var data = { foo: 'bar' }; history.pushState(data, '', '2.html'); console.log(history.state) // {foo: \"bar\"} 注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。 如果 pushState() 方法设置了一个跨域网址，则会报错。 // 报错 // 当前网址为 http://example.com history.pushState(null, '', 'https://twitter.com/hello'); 上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。 History.replaceState() 该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。 假定当前网页是 example.com/example.html。 history.pushState({page: 1}, '', '?page=1') // URL 显示为 http://example.com/example.html?page=1 history.pushState({page: 2}, '', '?page=2'); // URL 显示为 http://example.com/example.html?page=2 history.replaceState({page: 3}, '', '?page=3'); // URL 显示为 http://example.com/example.html?page=3 history.back() // URL 显示为 http://example.com/example.html?page=1 history.back() // URL 显示为 http://example.com/example.html history.go(2) // URL 显示为 http://example.com/example.html?page=3 popstate 事件 每当 history 对象出现变化时，就会触发 popstate 事件。 注意： 仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件; 只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。 页面第一次加载的时候，浏览器不会触发popstate事件。 使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。 window.addEventListener('popstate', function(e) { //e.state 相当于 history.state console.log('state: ' + JSON.stringify(e.state)); console.log(history.state); }); 点击查看 通过history.pushState 实现页面 tab 切换的功能。 history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。 "},"技术笔记/前端性能优化手段.html":{"url":"技术笔记/前端性能优化手段.html","title":"前端性能优化手段","keywords":"","body":"前端性能优化手段 [TOC] 一、缓存 欢迎来到「前端性能优化之旅」的第一站 —— 缓存。 当浏览器想要获取远程的数据时，我们的性能之旅就开始了。然而，我们并不会立即动身（发送请求）。在计算机领域，很多性能问题都会通过增加缓存来解决，前端也不例外。和许多后端服务一样，前端缓存也是多级的。下面让我们一起来具体看一看。 1. 本地数据存储 通过结合本地存储，可以在业务代码侧实现缓存。 对于一些请求，我们可以直接在业务代码侧进行缓存处理。缓存方式包括 localStorage、sessionStorage、indexedDB。把这块加入缓存的讨论也许会有争议，但利用好它确实能在程序侧达到一些类似缓存的能力。 例如，我们的页面上有一个日更新的榜单，我们可以做一个当日缓存： // 当用户加载站点中的榜单组件时，可以通过该方法获取榜单数据 async function readListData() { const info = JSON.parse(localStorage.getItem('listInfo')); if (isExpired(info.time, +(new Date))) { const list = await fetchList(); localStorage.setItem('listInfo', JSON.stringify({ time: +(new Date), list: list })); return list; } return info.list; } localStorage 大家都比较了解了，indexedDB 可能会了解的更少一些。想快速了解 indexedDB 使用方式可以看这篇文章[1]。 从前端视角看，这是一种本地存储；但如果从整个系统的维度来看，很多时候其实也是缓存链条中的一环。对于一些特殊的、轻量级的业务数据，可以考虑使用本地存储作为缓存。 2. 内存缓存（Memory） 当你访问一个页面及其子资源时，有时候会出现一个资源被使用多次，例如图标。由于该资源已经存储在内存中，再去请求反而多此一举，浏览器内存则是最近、最快的响应场所。 缓存并无明确的标准规定，它与 HTTP 语义下的缓存关联性不大，算是浏览器帮我们实现的优化，很多时候其实我们意识不到。 对内存缓存感兴趣，可以在这篇文章[2]的 Memory Cache 部分进一步了解。 3. Cache API 当我们没有命中内存缓存时，是否就开始发送请求了呢？其实不一定。 在这时我们还可能会碰到 Cache API 里的缓存，提到它就不得不提一下 Service Worker 了。它们通常都是配合使用的。 首先明确一下，这层的缓存没有规定说该缓存什么、什么情况下需要缓存，它只是提供给了客户端构建请求缓存机制的能力。如果你对 PWA 或者 Service Worker 很了解，应该非常清楚是怎么一回事。如果不了解也没有关系，我们可以简单看一下： 首先，Service Worker 是一个后台运行的独立线程，可以在代码中启用 // index.js if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js').then(function () { // 注册成功 }); } 之后需要处理一些 Service Worker 的生命周期事件，而其中与这里提到的缓存功能直接相关的则是请求拦截： // sw.js self.addEventListener('fetch', function (e) { // 如果有cache则直接返回，否则通过fetch请求 e.respondWith( caches.match(e.request).then(function (cache) { return cache || fetch(e.request); }).catch(function (err) { console.log(err); return fetch(e.request); }) ); }); 以上代码会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。与内存缓存不同，Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。 Service Worker 与 Cache API 其实是一个功能非常强大的组合，能够实现堆业务的透明，在兼容性上也可以做成渐进支持。还是非常推荐在业务中尝试的。当然上面代码简略了很多，想要进一步了解 Service Worker 和 Cache API 的使用可以看这篇文章[3]。同时推荐使用 Google 的 Workbox。 4. HTTP 缓存 如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了。这个时候出现的就是我们所熟知的 HTTP 缓存规范。 HTTP 有一系列的规范来规定哪些情况下需要缓存请求信息、缓存多久，而哪些情况下不能进行信息的缓存。我们可以通过相关的 HTTP 请求头来实现缓存。 HTTP 缓存大致可以分为强缓存与协商缓存。 4.1. 强缓存 在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。 与其相关的响应头则是 Expires 和 Cache-Control。在 Expires 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 Cache-Control 则可以通过给它设置一个 max-age，来控制过期时间。例如，max-age=300 就是表示在响应成功后 300 秒内，资源请求会走强缓存。 4.2. 协商缓存 你可能也感觉到了，强缓存不是那么灵活。如果我在 300 秒内更新了资源，需要怎么通知客户端呢？常用的方式就是通过协商缓存。 我们知道，远程请求慢的一大原因就是报文体积较大。协商缓存就是希望能通过先“问一问”服务器资源到底有没有过期，来避免无谓的资源下载。这伴随的往往会是 HTTP 请求中的 304 响应码。下面简单介绍一下实现协商缓存的两种方式： 一种协防缓存的方式是：服务器第一次响应时返回 Last-Modified，而浏览器在后续请求时带上其值作为 If-Modified-Since，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。 上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— ETag。服务器第一次响应时返回 ETag，而浏览器在后续请求时带上其值作为 If-None-Match。一般会用文件的 MD5 作为 ETag。 作为前端工程师，一定要善于应用 HTTP 缓存。如果想要了解更多关于 HTTP 缓存的内容，可以阅读这篇文章[4]。 上面这些的各级缓存的匹配机制里，都是包含资源的 uri 的匹配，即 uri 更改后不会命中缓存。也正是如此，我们目前在前端实践中都会把文件 HASH 加入到文件名中，避免同名文件命中缓存的旧资源。 5. Push Cache 假如很不幸，以上这些缓存你都没有命中，那么你将会碰到最后一个缓存检查 —— Push Cache。 Push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源。例如，你在请求 www.sample.com 时，服务端不仅发送了页面文档，还一起推送了 关键 CSS 样式表。这也就避免了浏览器收到响应、解析到相应位置时才会请求所带来的延后。 不过 HTTP/2 Push Cache 是一个比较底层的网络特性，与其他的缓存有很多不同，例如： 当匹配上时，并不会在额外检查资源是否过期； 存活时间很短，甚至短过内存缓存（例如有文章提到，Chrome 中为 5min 左右）； 只会被使用一次； HTTP/2 连接断开将导致缓存直接失效； …… 如果对 HTTP/2 Push 感兴趣，可以看看这篇文章[5]。 好了，到目前为止，我们可能还没有发出一个真正的请求。这也意味着，在缓存检查阶段我们就会有很多机会将后续的性能问题扼杀在摇篮之中 —— 如果远程请求都不必发出，又何须优化加载性能呢？ 所以，审视一下我们的应用、业务，看看哪些性能问题是可以在源头上解决的。 不过很多时候，能通过缓存解决的问题只有一部分。所以下面我们会继续这趟旅行，目前我们已经有了一个好的开始，不是么？ 二、发送请求 在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。 在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。 介绍网络请求其实可以包含复杂的网络知识。不过，今天咱们的旅程主要聚焦于“前端性能优化”。因此，主要会介绍一些在这个环节中，前端性能优化可能会做的事儿。 1. 避免多余重定向 重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。 重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。 同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。 2. DNS 预解析 基本我们访问远程服务的时候，不会直接使用服务的出口 IP，而是使用域名。所以请求的一个重要环节就是域名解析。 DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下： 先检查本地 hosts 文件中是否有映射，有则使用； 查找本地 DNS 缓存，有则返回； 根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS； 如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求； 根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名； 当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。 更详细的介绍可以看这篇文章[1]。 这里我们需要了解的是： 首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入； 其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。 DNS Prefetch[2] 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单： 1当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了👇 user agent SHOULD resolve as early as possible 3. 预先建立连接 我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 Preconnect[3] 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。” 根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理： 首先，解析 Preconnect 的 url； 其次，根据当前 link 元素中的属性进行 cors 的设置； 然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false； 最后，进行连接。 使用 Preconnect 只需要将 rel 属性设为 preconnect 即可： 当然，你也可以设置 CORS： 需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。 4. 使用 CDN 当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。 对于静态资源，我们可以考虑通过 CDN 来降低时延。 对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。 想了解更多 CDN 的工作方式可以阅读这篇文章[4]。 下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。 在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。 过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。 三、服务端响应 把这一部分放进前端性能优化并不是很严谨： 其一，服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域； 其二，我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。 所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。 1. 使用流进行响应 目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。 例如 css-only-chat-node 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。 2. 业务聚合 BFF 非常合适做的一件事就是后端服务的聚合。 如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。 此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。 3. 避免代码问题 代码问题其实就非常细节了。简单列举一些常见的问题： async await 的不当使用导致并行请求被串行化了； 频繁地 JSON.parse 和 JSON.stringify 大对象； 正则表达式的灾难性回溯； 闭包导致的内存泄漏； CPU 密集型任务导致事件循环 delay 严重； 未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源； …… 「前端性能优化之旅」在这一阶段只能蜻蜓点水了。NodeJS 作为 BFF 还是比较常见的，所以在旅途中也提了一下。下面我们就要重新回到前端领域了，准备好了么？ 四、页面解析与处理 在上一站中，我们简单介绍了服务端处理与响应，到目前为止我们已经经历了很多环节，也已经有了许多「性能优化的武器」。像是 利用各级缓存进行优化 提前进行 DNS 查询或建立连接等方式加速请求 在服务端避免不必要的耗时 …… 不过，不要掉以轻心，后续仍然有大量的工作等待我们来优化。下面就到了客户端接收响应的阶段了。 主要工作 这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分： 页面 DOM 的解析； 页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等； 静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等； 大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。 1. 注意资源在页面文档中的位置 我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。 JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。 仅仅看 DOM 与 CSS 的关系，则如下图所示： HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了： 根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 —— JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。 所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 之中（即页面的头部），把 JavaScript 脚本放在 的最后（即页面的尾部）。 关于这部分的一些解释可以看这篇文章[1]。 2. 使用 defer 和 async 上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。 那除了将脚本放在 body 的最后，还有什么优化方法么？是有的。 可以使用 defer 或 async 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下： defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。 根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 async 可以有效避免这些非核心功能的加载影响页面解析速度。 3. 页面文档压缩 HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。 说一句题外话，你知道与页面解析密切相关的 DOMContentLoaded 事件何时么？interactive/complete 等 readyState 具体代表什么么？如果不太了解可以从HTML spec[2]里看。 用原话来说就是： Returns \"loading\" while the Document is loading, \"interactive\" once it is finished parsing but still loading subresources, and \"complete\" once it has loaded. The readystatechange event fires on the Document object when this value changes. The DOMContentLoaded event fires after the transition to \"interactive\" but before the transition to \"complete\", at the point where all subresources apart from async script elements have loaded. 好了，在这一站我们又了解了页面的解析过程及其性能优化。 正如开头所说，其实解析页面、加载资源、使用资源是三个紧密相关的过程。在这里我们主要着眼于页面的解析，而在「前端性能优化之旅」的下一站，我们则会一起来涉足到这部分的其他诸多优化点中。 五、页面静态资源 在旅程的上一站中，我们介绍了基本的页面解析机制，通过对资源加载顺序和脚本加载的控制，避免了无谓的阻塞，优化了解析性能。 也正如上一站中所说，这时浏览器除了解析页面 DOM 外，还会对页面包含的静态资源发起请求，请求回来后会执行或使用资源。这一站咱们就来具体看看这个阶段。 首先还是从宏观上来了解一下： 1. 总体原则 这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。 但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于： 减少不必要的请求 减少包体大小 降低应用资源时的消耗 利用缓存 为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。 1.1. 减少不必要的请求 核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。 同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。 减少不必要的请求主要分为几个维度： 对于不需要使用的内容，其实不需要请求，否则相当于做了无用功； 对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载； 对于可以合并的资源，进行资源合并也是一种方法。 1.2. 减少包体大小 包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。 减少包体大小常用的方式包括了： 使用适合当前资源的压缩技术； 避免再响应包体里“塞入”一些不需要的内容 1.3. 降低应用资源时的消耗 以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。 此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。 1.4. 利用缓存 还记得咱们这趟旅程从哪出发的么？没错，缓存。 在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。 由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。 2. 针对各类资源的性能优化 🚀 以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。 如果你一口气读到这里，可能有些累了。不如先伸个懒腰放松下，整理回忆一下之前的内容。 如果准备好了，咱们就继续出发吧👇 JavaScript 优化 CSS 优化 图片优化 字体优化 视频优化 本节告一段落 好了，如果你已经阅读完了上面各类资源的具体优化措施，那么恭喜，你已经在「前端性能优化之旅」上行过大半。下面我们会收拾行装继续回到主路上。 下一站我们会来到“运行时”（runtime），看看有哪些性能优化的注意点与技术手段。 六、运行时 虽然我们已经趟过了资源加载这个优化的大头，但仍然不能掉以轻心，在应用运行时你仍然可能踩到一些性能的“坑”。下面就让我们来具体看一看。 1. 注意强制同步布局 1.1. 什么是强制同步布局 作为前端，大家应该对“强制同步布局”并不陌生。如果你不太了解，这里简单介绍一下。首先你需要知道的是，显示器有一个自己的刷新频率，例如每秒 60 次（60 FPS）。这就意味着，每过 16.6ms，浏览器就会将截止上次刷新后的元素变动应用到屏幕上。这里就不得不提到渲染管线了。 在渲染管线中，有一步叫做 Layout，也就是布局。它会计算元素的大小、位置信息，而且一处的改动几乎会影响到整个文档页面。所以 Layout 的消耗是非常巨大的。而我们所说的 reflow（firefox）与 layout（Chrome/Opera/Safari/IE），都是指的这一过程。另一方面，渲染线程和 JavaScript 执行线程是互斥的，所以这 16.6ms 还会被 JavaScript 的执行所瓜分，可见时间并不那么“富裕”。 我们先来看一段代码： var $ele = document.getElementById('main'); var height = $ele.offsetHeight; // …… 上述代码获取了元素的 offsetHeight 值，浏览器此时会使用上一次渲染后的缓存值进行返回，所以浏览器消耗并不大。 而有一些 JavaScript 操作会导致浏览器需要提前执行布局操作，这种操作就被称为“强制同步布局”。我们把上面的代码改成如下所示： var $ele = document.getElementById('main'); $ele.classList.remove('large'); var height = $ele.offsetHeight; // …… 由于我们在修改元素的 className 后又立刻获取了它的高度，为了保证高度值正确，浏览器会立即进行布局，然而我们的本意可能并非如此 —— 也许 large 并不会影响高度，也许我们只是想获取上一帧的结果…… 针对这种目的，下面的写法会更合适，同时可以避免强制同步布局。 var height = $ele.offsetHeight; var $ele = document.getElementById('main'); $ele.classList.remove('large'); // …… 从这个例子可以看到，我们很可能一不小心就触发了强制同步布局。除了上例中的 offsetHeight，还有许多会触发强制同步布局[1]的属性。而 CSS Triggers[2] 这个网站在 Layout 之外，列出了各个浏览器中会触发 Paint 和 Composite 的 CSS 属性。 1.2. 尝试使用 RAF 避免强制同步布局 在强制同步布局的问题上，还有一些更严重的列子，例如在循环中不断触发强制同步布局。 如果你希望避免在浏览器进行页面重绘后执行一些操作，你可以使用 requestAnimationFrame API。由于上一帧的旧布局值是可以直接获取的，所以我们可以将布局查询的操作放在 requestAnimationFrame 中。 window.requestAnimationFrame(() => { var $ele = document.getElementById('main'); var height = $ele.offsetHeight; // …… }); 但是请注意，如果像下面这样犯了和之前一样的错误，在查询布局之前设置了新的元素样式/布局属性，那使用了 requestAnimationFrame 也无法避免性能问题。 window.requestAnimationFrame(function () { var $ele = document.getElementById('main'); $ele.classList.remove('large'); var height = $ele.offsetHeight; // …… }); 1.3. 批量化你的操作 批量化是计算机程序优化中的重要手段之一。例如一些数据库在写操作上最终也是会将其批量化后再统一进行磁盘 I/O。所以对于元素布局的查询操作，我们也可以尝试使用这种手段。我们可以将这些操作批量化存储下来，等到下一次 requestAnimationFrame 触发时一起执行。FastDom 就是一个帮你封装了这类操作的开源库 By batching DOM access we avoid unnecessary document reflows and dramatically speed up layout performance. Each measure/mutate job is added to a corresponding measure/mutate queue. The queues are emptied (reads, then writes) at the turn of the next frame using window.requestAnimationFrame. 上面是它的基本工作原理，和我们提到的思路是一样的。基本的使用方法如下： fastdom.measure(() => { const width = element.clientWidth; }); fastdom.mutate(() => { element.style.width = width + 'px'; }); 2. 长列表优化 有些时候，你可能会需要在页面上展示一个包含上百个元素的列表（例如一个 Feed 流）。每个列表元素还有着复杂的内部结构，这显然提高了页面渲染的成本。甚至当你使用一些像 React 这样的库时，长列表的问题会被进一步放大。那么，有没有什么方法来优化长列表呢？ 2.1. 实现 Virtual List Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表元素。下图左边就是 Virtual List 的效果，可以看到只有视口内和临近视口的上下区域内的元素会被渲染。 不过这样带来的一个问题就是，由于只渲染固定 N 个元素，所以在页面滚动后，它们仍然留在原位。对于这个问题可以使用 position: absolute 配合 transform: translate3d() 来解决，手动设置展示元素的偏移量。 其大致的实现思路如下： 监听页面滚动（或者其他导致视口变化的事件）； 滚动时根据滚动的距离计算需要展示的列表项； 将列表项中展示的数据与组件替换成当前需要展示的内容； 修改偏移量到对应的位置。 这样还有一个好处，相当于是不断改变这 N 个元素的位置属性和内部的一些节点，不会有频繁的 DOM 创建与销毁，配合下面提到的 composite 可以获得不错的性能。 如果你想要使用这项技术，除了自己实现外，一些常见的框架也有不错的开源实现。例如： 基于 React 的 react-virtualized，它的开发者也在 dev.to 上分享了一些关于 virtual list 的内容[3]； 基于 Vue 的 vue-virtual-scroll-list； 基于 Angular 的 ngx-virtual-scroller； …… 2.2. 原生的 Virtual Scroller Virtual List 在 feed 流、图片库等很多场景下非常有用，开源组件的下载量也说明了业务对这个功能的需求量。那么自然会想到，如果由浏览器层面来提供类似的能力，显然适用性会更强，性能可能也会更好。Virtual Scroller 就是上述逻辑的浏览器原生实现。Chrome Dev Summit 2018[4] 上演示了它的效果。使用上也很简单： import \"std:virtual-scroller\"; item 1 item 2 item 3 item 4 …… item 1000 注意， 是内置（built-in）模块提供的，所以需要从 std 中导入。目前（2019.08）还不建议在生产环境中使用该功能。如果想得到类似的效果还是建议使用基于 JavaScript 实现的库。当然，非常期待未来在生产环境中可以用上这个功能。 想了解更多关于 Virtual Scroller 的信息可以看这里[5]。 3. 避免 JavaScript 运行时间过长 上面我们提到了，屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。下面我们来看下如何避免 JavaScript 长时间执行而导致的掉帧。 3.1. 任务分解 你可以在 Chrome 控制台执行如下命令： document.body.innerHTML = ''; for(var i = 0; i 可以看到页面被立即清空了。然后我们修改一下迭代的次数，从 100 次增加到 10 亿次： document.body.innerHTML = ''; for(var i = 0; i 这时候运行你会发现页面没有变化，控制台也卡住了。过了几秒后页面被清空了。这是因为 JavaScript 的长时间执行阻塞了渲染线程。 既然长时间的运行会导致渲染阻塞，那么最简单的方法就是把我们的任务拆成一个个持续时间更短的小任务，分散到各个帧中执行，例如改造成下面这样： document.body.innerHTML = ''; let step = 0; function subtask() { if (step === 1e9) { return; } window.requestAnimationFrame(function () { for(var i = 0; i 我们把 10 亿次分散为十个 1 亿次的子任务，虽然同样执行了 10 亿次计算，但是页面迅速被清空了。 此外，浏览器还有一个更强大的 API 来帮助你更精细地进行计算调度，它就是 requestIdleCallback。它会在浏览器“空闲”的时候执行注册的回调函数，避免在主线程“拥挤”的时候执行某些代码。它支持你设定一个超时参数，保证在超时后，即使仍然没有空闲时间也必须执行回调。回调函数会接收一个 IdleDeadline 类型的参数，你可以通过 .didTimeout 来查看是否是超时执行，还可以通过执行 .timeRemaining() 方法来查看剩余的空闲时间。 window.requestIdleCallback(deadline => { if (deadline.timeRemaining() > 100) { // 一些可以等浏览器空闲了再去做的事 // …… } }, {timeout: 5000}) 上面是基本的使用方式，具体的使用方式可以查看这里[6] 3.2. 延迟执行 一般来说，延迟执行分为两种策略： 一种是懒执行，例如当我需要某个值时，我才去计算； 第二种是延后执行，即利用 setTimeout、requestIdleCallback 这样的方法把计算放到后续的事件循环或空闲时刻。 一些场景下，这两个都是可行的方法。除此以外，在 Idle Until Urgent[7] 中作者介绍了一种改进的方法：把计算放到 requestIdleCallback 中，如果你一直不需要用到计算结果也没有关系，它会等到空闲时再执行，不影响性能；而当你要使用时，如果还未计算好则会立刻进行计算并返回结果，同时取消未执行的 requestIdleCallback。 我们在这两部分都提及了 requestIdleCallback，它确实是个非常不错的 API，然而目前（2019.08）兼容性不是很乐观。如果你希望在生产环境中使用，建议使用 polyfill。 3.3. 并行计算 对于一些 CPU 密集型的计算场景，除了在主 JavaScript 线程中拆分调度任务、异步执行之外，我们还可以考虑将计算与主线程并行。在浏览器中启用并行线程可以使用 Web Worker[8] 中。在 Web Worker 标准出现之前，你能做的只是将任务异步化（asynchronously），而有了 Web Worker，你就可以并行（concurrency）地执行 JavaScript 了。 下面提供了 Web Worker 的基本使用方式： // index.js const worker = new Worker('worker.js'); worker.addEventListener('message', function (e) { console.log(`result is ${e.data}`); }, false); worker.postMessage('start'); // worker.js self.addEventListener('message', function (e) { if (e.data === 'start') { // 一些密集的计算…… self.postMessage(result); } }, false); 4. 善用 Composite Composite 这个概念和我们的渲染管线关系密切，可以看到它处于最后一步。 由于之前我们说到，元素布局可能会影响到整个页面，那么自然我们就会想，是否能尽可能减少影响的范围呢？在某些情况下是可以的。例如下面这两个元素： .main { height: 200px; width: 200px; background: black; } .fixed { position: fixed; top: 20px; left: 20px; transform: translateZ(0); width: 100px; height: 100px; background: red; } 浏览器会将其处理为两个渲染层，其中 .fixed 元素由于设置了 3D transform，所以会从普通的渲染层提升至合成层，拥有独立的 GraphicsLayers。当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。下图展示了当前的两个合成层： 总得来说，合成层在性能优化上的优点在于： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快； 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层； 对于 transform 和 opacity 效果，不会触发 layout 和 paint。 但同时，也要注意避免层爆炸，防止在无法进行层压缩的情况下出现过多的层，反而导致性能的下降。这篇文章介绍了 composite 的原理及其相关应用[9]。 5. 滚动事件的性能优化 前端最容易碰到的性能问题的场景之一就是监听滚动事件并进行相应的操作。由于滚动事件发生非常频繁（相较于用户点击、hover 等事件），所以频繁地执行监听回调就容易造成 JavaScript 执行与页面渲染之间互相阻塞的情况。 滚动的性能优化其实也是一种综合性的优化。它主要是会将上述的各类性能问题放大了，所以在优化措施中，你仍然需要避免出现上面提到的长时间的 JavaScript 执行、强制同步布局等问题。 此外，基于滚动这个特殊场景，这里再介绍两个处理滚动性能时非常常见的技术：防抖和节流。 当一个事件频繁触发，而你希望间隔一定的时间再触发相应的函数时就会使用节流（throttle）。例如在页面滚动时，每 200ms 进行一次页面背景颜色的修改。 当一个事件频繁触发，而你希望在事件触发结束一段时间后（此段时间内不再有触发）才实际触发响应函数时会使用防抖（debounce）。例如用户一直点击按钮，但你不希望频繁发送请求，你就可以设置当点击后 200ms 内用户不再点击时才发送请求。 这两个技术也是前端非常常用的技术，例如 lodash 中就有 throttle 和 debounce 的对应实现。如果你对它们不太了解，可以看下面这两篇文章： 函数节流的实现 (throttle)[10] 函数去抖的实现 (debounce)[11] 6. Passive event listeners 在介绍 Passive event listeners 是如何让滚动更顺畅之前，我们先来看下为什么会有 Passive event listeners。 考虑下面这段代码： document.addEventListener('touchstart', function (e) { // 做了一些操作…… e.preventDefault(); }, true); 我们知道，在 touchstart 中调用了 e.preventDefault() 会阻止页面的滚动与缩放。那么浏览器是如何知道不要让页面滚动与缩放的呢？当然是因为我们调用了 e.preventDefault()，你可能认为这是废话，不过问题就在这。如果浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件。所以不管你是否调用了 e.preventDefault()，当你添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费事件执行完你的回调，然后根据结果来判断是否需要滚动页面。如果的操作花费了 200ms，那页面只能在 200ms 后再滚动或缩放，这就导致了性能问题。 那你肯定会想，很多时候我不会阻止默认事件呀，我有没有办法告诉浏览器，让它不用等啦（默认行为没有被禁用），直接滚动页面就行呢？Passive event listeners 就是为此而生的[12]。使用方式很简单： document.addEventListener('touchstart', function (e) { // 做了一些操作…… }, {passive: true}); 只需要在第三个参数中传入 {passive: true} 即可。 然而和其他新特性一样，对于 Passive event listeners 我们也需要考虑兼容性。由于在低版本浏览器中，第三个参数是用来设置是否进行事件捕获的。所以使用时建议进行特性检测： // 这段特性检测的方法很巧妙 let supportsPassive = false; try { const opts = Object.defineProperty({}, 'passive', { get: function() { supportsPassive = true; } }); window.addEventListener('testPassive', null, opts); window.removeEventListener('testPassive', null, opts); } catch (e) {} document.addEventListener('touchstart', function (e) { // 做了一些操作…… }, supportsPassive ? {passive: true} : false); 这个视频展示了 Passive event listeners 带来的性能与体验提升，视频中右侧画面是使用了 Passive event listeners 的效果。 运行时性能是前端性能优化中非常重要的一块。这篇文章里列举了常见场景下的通用优化手段。才外，目前大多数应用都是构建在 React/Vue/Angular 之上（当然也有 jQuery），针对具体框架的性能优化又会是好几个新的话题，后续如果有机会也希望能将它们补充进来。 不过，不管什么框架在前端最终都会运行在浏览器上、使用 JavaScript 引擎（至少目前是），所以这些针对以这些通用性的性能优化思路作为基础，可以帮你更好理解与处理遇到的性能问题。 七、预加载 在之前的旅途中，我们提到了很多关于资源加载的优化，包括怎么加快连接的建立、怎么减少包体大小、怎么减少请求数等。但还有一种变相加快加载速度的技术 —— 预加载。 预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。 在「性能优化之旅」的最后一站，我会给你介绍一些预加载技术，包括使用览器提供的能力，或者巧用 JavaScript 中的相关 API。此外，除了预加载技术，预加载的一大核心问题还在于预加载策略，即如何判断资源是否需要预加载以及合适加载，以保证最高的效率。 1. 预加载技术 1.1. Resource Hints Resource Hints[1] 是一种预加载相关的标准，它告诉浏览器哪些源下的资源我们的 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender。此外，还有一个与 Resource Hints 类似的 Preload 我们也会在这里介绍一下。 在发起请求部分我们已经介绍了如何使用 DNS Prefetch 来预解析 DNS、如何使用 Preconnect 来预先建立连接。所以下面会其他三块：Prefetch、Prerender、Preload。 1.1.1. Prefetch 你可以把 Prefetch 理解为资源预获取。一般来说，可以用 Prefetch 来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。其中 as 属性用于指定资源的类型，与 Preload 规范一致，基本涵盖了所有资源类型[2]。 1.1.2. Prerender Prerender 比 Prefetch 更进一步，可以粗略地理解不仅会预获取，还会预执行。 The prerender link relation type is used to identify a resource that might be required by the next navigation, and that the user agent SHOULD fetch and execute. 如果你指定 Prerender 一个页面，那么它依赖的其他资源，像 、 等页面所需资源也可能会被下载与处理。但是预处理会基于当前机器、网络情况的不同而被不同程度地推迟。例如，会根据 CPU、GPU 和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。 1.1.3. Preload 在遇到需要 Preload 的资源时，浏览器会 立刻 进行预获取，并将结果放在内存中，资源的获取不会影响页面 parse 与 load 事件的触发。直到再次遇到该资源的使用标签时，才会执行。由于我们会将 标签置于 底部来保证性能，因此可以考虑在 标签中适当添加这些资源的 Preload 来加速页面的加载与渲染。 到这里大家肯定会好奇，Preload 与 Prefetch 有什么区别呢？它们非常容易混淆，在标准里有这么一段话解释两者区别： The application can use the preload keyword to initiate early, high-priority, and non-render-blocking fetch of a CSS resource that can then be applied by the application at appropriate time. 与 Prefetch 相比，Preload 会强制浏览器立即获取资源，并且该请求具有较高的优先级（mandatory and high-priority），因此建议对一些当前页面会马上用到资源使用 Preload；相对的，Prefetch 的资源获取则是可选与较低优先级的，其是否获取完全取决于浏览器的决定，适用于预获取将来可能会用到的资源。 如果对 Resource Hints 感兴趣，可以在我之前的文章中进一步了解它们[3]。 1.1.4. webpack 中的使用方式 预加载可以配合 code split 来使用，可以在降低初始加载量的情况下，尽量保证按需加载时的体验。在 webpack 中应用预加载[4]非常简单，只需要在 dynamic import 中添加相应注释，webpack 就会知道你需要对这个 chunk 进行预加载。 // prefetch import(/* webpackPrefetch: true */ './sub1.js'); // preload import(/* webpackPreload: true */ './sub2.js') 1.2. 基于 JavaScript 的预加载 上面提到了基于 Resource Hints 的预加载技术，它其实像是一种声明式技术：你提出你的预加载需求，浏览器根据自身状态，选择合适的时候预加载。 如果你在不兼容 Resource Hints 的浏览器上进行预加载，或者希望有“更强硬的”预加载控制，你可能会希望使用一些 JavaScript 中的功能来“巧妙”地进行预加载。 例如对于图片， let img = new Image(); img.src = '/static/img/prefetch.jpg'; 上面的方法会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。 对于 JavaScript 和 CSS 可以动态添加 和 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）。 如果你希望通过 JavaScript 来进行预加载，可以使用 PreloadJS 这个库，它提供了包括脚本、样式、图片、字体、SVG等各类资源的预加载器。 2. 视频预加载 视频预加载技术可以有效提高视频播放的用户体验。在 Fast Playback with Video Preload[5] 中提到了三种视频预加载方式。 2.1. 为视频添加 preload 属性 使用 preload 属性可以让浏览器预加载相应的内容。其取值与作用如下表所示： 值 作用 none 不载入视频（即不预加载） meta 载入元数据（时长、尺寸、文字轨道） auto 加载整个视频 此外，你还可以设置 poster 属性，它规定视频下载时或用户点击播放按钮前播放器上显示的图像。一种推荐的方式是设置 poster 与 preload: meta，为用户提供一定的播放预览信息的同时避免过多的预加载流量。 2.2. 使用 Preload Link 这一点已经在第一部分提到了，可以使用 进行资源的预加载。 2.3. 使用 JavaScript 进行自定义的 Buffer 操作 可以通过 HTTP Range 请求头来获取开始的一小段视频数据，然后使用 MediaSource API 来进行视频媒体数据的暂存与播放。 下面这段示例代码摘自 Fast Playback with Video Preload - Manual buffering，它可以实现视频数据的预加载，更多相关实现可以参见其中内容。 const mediaSource = new MediaSource(); video.src = URL.createObjectURL(mediaSource); mediaSource.addEventListener('sourceopen', sourceOpen, { once: true }); function sourceOpen() { URL.revokeObjectURL(video.src); const sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs=\"vp09.00.10.08\"'); // Fetch beginning of the video by setting the Range HTTP request header. fetch('file.webm', { headers: { range: 'bytes=0-567139' } }) .then(response => response.arrayBuffer()) .then(data => { sourceBuffer.appendBuffer(data); sourceBuffer.addEventListener('updateend', updateEnd, { once: true }); }); } function updateEnd() { // Video is now ready to play! var bufferedSeconds = video.buffered.end(0) - video.buffered.start(0); console.log(bufferedSeconds + ' seconds of video are ready to play!'); // Fetch the next segment of video when user starts playing the video. video.addEventListener('playing', fetchNextSegment, { once: true }); } function fetchNextSegment() { fetch('file.webm', { headers: { range: 'bytes=567140-1196488' } }) .then(response => response.arrayBuffer()) .then(data => { const sourceBuffer = mediaSource.sourceBuffers[0]; sourceBuffer.appendBuffer(data); // TODO: Fetch further segment and append it. }); } 3. 预加载的策略 预加载一般都会面临一些矛盾： 预加载资源过多，可能导致流量消耗过大，占用正常请求的通道； 预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。 设计一个高效的预加载策略是一个很复杂的问题 ，这里只简单介绍一些工具。 3.1. quicklink quicklink 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式。它的策略其实非常直接，核心就是当链接进入到视口后，会对其进行预加载。 当然我们还可以加一些其他策略，例如设定一个 200ms 的停留阈值。总体而言，它的策略还是比较简单的，更像是为前端预加载提供一个思路。如果感兴趣，可以从这篇文章中了解 quicklink 的实现细节[6]。 3.2. Guess.js Guess.js 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。同时，在预加载之外，它还可以帮助实现最优的打包方式、加载路径等。核心就是通过大量的实际用户数据，来帮助前端性能优化做决策与预测。 你可以查看 Guess.js Repo 来进一步了解它，或者阅读这篇介绍文章[7]。 关于预加载的话题就到这了，我们的「前端性能优化之旅」也接近尾声了。最后一站，让我们再回来从整体维度聊聊前端性能优化吧。 尾声 我们这次的「前端性能优化之旅」已经到了尾声，还记得我们这次旅程的初衷么 —— 从整个前端访问链条的角度，来理解与掌握前端性能优化的知识和技术。 最后，再和大家聊一聊性能优化实践相关的话题。 1. 性能指标 Web 发展到现今阶段，性能指标已经不再只是 DOMContentLoad 和 load 这样的“面向浏览器”的指标，更多的会是以用户为中心（user-centric）的指标，例如： FP (First Paint) FID (First Input Delay) FCP (First Contentful Paint) FMP (First Meaningful Paint) TTI (Time to interactive) …… 所以在性能优化之前最重要的还是明确你的监控指标和分析维度，关于性能指标其实也是一个可以继续聊下去的内容，这里就不展开了，以后有机会希望把这部分也补充进来。 2. 持续优化 性能优化很多时候不是一蹴而就的，更不是一锤子买卖。一个良好的性能优化方案一定是一个持续循环的体系。 一个合理的性能优化方案，一定是通过线上的性能监控数据，或者前端自动化性能测试分析，发现性能问题，针对发现的问题进行分析与定位，然后进行对应的性能优化，最后上线观察。之后又会进入到下一个性能优化的循环中。所以推行性能优化，一定要注重优化工程的可持续性。 3. 监控与测试 💻 性能监控与测试也是一块非常大的话题，包括监控的手段、分析的维度等等，如果后续有机会希望把这块再补充上来。这里先介绍一下。 我们一般会把性能数据分为两种[1]： 一种叫 Lab data，主要是在开发和测试人员本地或内部测试机器上跑出来的数据，例如在 CI/CD 中加入 lighthouse。它的优点在于采集的指标更全面，也易于复现问题；缺点主要在于有时候可能不能反应真实的用户体验情况。 另一种叫 Field data，也被成为 RUM (Real User Monitoring)，是指采集线上实际的性能数据来进行监控。它的优点则是能更好地发现用户实际遇到的性能问题；缺点主要是比较难以调试与复现问题，同时采集到的指标的详细程度不及 Lab data。 而 The Three Types of Performance Testing[2] 则进一步划分出了三类性能测试。 第一种叫做 Proactive：它可以理解为是工程师在开发阶段，通过浏览器调试等本地工具来发现并解决性能问题（善于利用 Chrome DevTools[3] 也是一个优秀前端工程师所需要具备的 😊）； 第二种叫做 Reactive：它是一种自动化的性能测试，可以集成到自动化测试或流水线的其他阶段，会在构建与每次发布前执行； 第三种叫做 Passive：它就是在产品发布后，通过收集线上数据（或用户反馈）来发现性能问题，主要是基于一些 RUM。 选择哪种性能测试呢？答案是将它们结合使用（就像是自动化测试会结合单元测试、集成测试与端到端测试）。 对于一些易于标准化的性能标准，可以考虑使用 Proactive 和 Reactive 这样的 Lab data 来避免性能问题；而对于更复杂的业务场景，则可以通过 Passive 模式下的 Field data 进行监控。 4. 自动化 🛠 在性能优化上，请务必将可以自动化的工作都自动化。 前端性能优化的链路包括了「缓存 -> 发送请求 -> 等待响应 -> 解析 -> 处理各类静态资源 -> 运行时 -> 预加载（等待后续的请求）」，还是比较复杂的。因此，建议通过一些工具来将工作自动化。否则很可能无法保证性能优化的持续实施，因为它从来不是一锤子买卖。 在旅程中的各个技术点上，我也都会提到一些帮助快速实现优化或自动化的工具，例如 Workbox 提供的各类缓存方案、图片压缩的工具、webpack 插件等。还包括上面提到的，可以在 CI/CD 中集成的 lighthouse[4] 这样的分析工具。而对于 RUM，如果你们公司有人力可以自建一套体系，如果自建成本较高，可以考虑接入一些免费或收费的商业公司产品。 "},"技术笔记/前端性能优化之白屏时间.html":{"url":"技术笔记/前端性能优化之白屏时间.html","title":"前端性能优化之白屏时间","keywords":"","body":"前端性能优化之白屏时间 [TOC] 前言 该篇文章会为您分享在前端性能优化中非常重要的一环-白屏时间，将从白屏时间的概念、重要性以及白屏的过程一一进行阐述，同时提供性能优化的策略与实践。 一、概念 白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 白屏时间的长短将直接影响用户对该网站的第一印象。 二、白屏时间的重要性 当用户点开一个链接或者是直接在浏览器中输入URL开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。 打开一个页面就像你的女票召唤你一样，你出现的越迅速，女票肯定会愈加欣喜！反之，你千呼万唤始出来，那么你的女票很可能又要抛弃你了(为什么要对你说又呢? ...) 三、白屏是一个怎样的过程呢？ 让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！ 1. DNS Lookup DNS Lookup 即浏览器从DNS服务器中进行域名查询。 浏览器会先对页面进行域名解析，获取到服务器的IP地址后，进而和服务器进行通信。 Tips: 通常在整个加载页面的过程中，浏览器会多次进行DNS Lookup，包括页面本身的域名查询以及在解析HTML页面时加载的JS、CSS、Image、Video等资源产生的域名查询。 2. 建立TCP请求连接 浏览器和服务端TCP请求建立的过程，是基于TCP/IP，该协议由网络层的IP和传输层的TCP组成。IP是每一台互联网设备在互联网中的唯一地址。 TCP通过三次握手建立连接，并提供可靠的数据传输服务。 3. 服务端请求处理响应 在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。 Web服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS文件、静态HTML直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。 在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据 4. 客户端下载、解析、渲染显示页面 在服务器返回数据后，客户端浏览器接收数据，进行HTML下载、解析、渲染显示。 a. 如果是Gzip包，则先解压为HTML b. 解析HTML的头部代码，下载头部代码中的样式资源文件或脚本资源文件 c. 解析HTML代码和样式文件代码，构建HTML的DOM树以及与CSS相关的CSSOM树 d. 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树 e. 根据渲染树完成绘制过程 浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。 Tips:浏览器安全解析策略对解析HTML造成的影响： 当解析HTML时遇到内联JS代码，会阻塞DOM树的构建 特别悲惨的情况： 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时！！！根据浏览器的安全解析策略，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。 一定要合理放置JS代码！！！ 四、白屏-性能优化 至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。 1. DNS解析优化 针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。 DNS缓存优化 DNS预加载策略 稳定可靠的DNS服务器 2. TCP网络链路优化 针对网络链路的优化，好像除了花钱没有什么更好的方式！ 3. 服务端处理优化 服务端的处理优化，是一个非常庞大的话题，会涉及到如Redis缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等... 4. 浏览器下载、解析、渲染页面优化 根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理： 尽可能的精简HTML的代码和结构 尽可能的优化CSS文件和结构 一定要合理的放置JS代码，尽量不要使用内联的JS代码 "},"技术笔记/前端性能优化指标之RAIL.html":{"url":"技术笔记/前端性能优化指标之RAIL.html","title":"前端性能优化指标之RAIL","keywords":"","body":"前端性能优化 - 用RAIL模型分析性能 RAIL是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。 有以下四个方面： Response Animation Idle Load 聚焦用户 以下是用户对性能延迟的感知： 延迟时间 用户感知 0-16ms 很流畅 0-100ms 基本流畅 100-1000ms 感觉到网站上有一些加载任务 1000ms or more 失去耐心了 10000ms or more 直接离开，不会再访问了 Response: 事件处理最好在50ms内完成 目标 用户的输入到响应的时间不超过100ms，给用户的感受是瞬间就完成了。 优化方案 事件处理函数在50ms内完成，考虑到idle task的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations等，不适用于drag和scroll。 复杂的js计算尽可能放在后台，如web worker，避免对用户输入造成阻塞 超过50ms的响应，一定要提供反馈，比如倒计时，进度百分比等。 idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。 下图是idle task对input response的影响： Animation: 在10ms内产生一帧 目标 产生每一帧的时间不要超过10ms，为了保证浏览器60帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧。 旨在视觉上的平滑。用户对帧率变化感知很敏感。 优化方案 在一些高压点上，比如动画，不要去挑战cpu，尽可能地少做事，如：取offset，设置style等操作。尽可能地保证60帧的体验。 在渲染性能上，针对不同的动画做一些特定优化 动画不只是UI的视觉效果，以下行为都属于 视觉动画，如渐隐渐显，tweens，loading等 滚动，包含弹性滚动，松开手指后，滚动会持续一段距离 拖拽，缩放，经常伴随着用户行为 Idle: 最大化空闲时间 目标 最大化空闲时间，以增大50ms内响应用户输入的几率 优化方案 用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 requestIdleCallback API 在空闲时间内执行的任务尽量控制在50ms以内，如果更长的话，会影响input handle的pending时间 如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务 Load: 传输内容到页面可交互的时间不超过5秒 如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率 目标 优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的3G网络手机上打开时间不超过5秒 对于第二次打开，尽量不超过2秒 优化方案 在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 WebPageTest 来测试 要注意的是，即使用户的网络是4G，但因为丢包或者网络波动，可能会比预期的更慢 禁用渲染阻塞的资源，延后加载 可以采用 lazy load，code-splitting 等 其他优化 手段，让第一次加载的资源更少 "},"技术笔记/事件模型.html":{"url":"技术笔记/事件模型.html","title":"事件模型","keywords":"","body":"事件模型 [TOC] 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章介绍 DOM 的事件编程。 1. EventTarget 接口 DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法。 addEventListener：绑定事件的监听函数 removeEventListener：移除事件的监听函数 dispatchEvent：触发事件 1.1 EventTarget.addEventListener() EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。 该方法接受三个参数。 type：事件名称，大小写敏感。 listener：监听函数。事件发生时，会调用该监听函数。 useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为false（监听函数只在冒泡阶段被触发）。该参数可选。 下面是一个例子。 function hello() { console.log('Hello world'); } var button = document.getElementById('btn'); button.addEventListener('click', hello, false); 上面代码中，button节点的addEventListener方法绑定click事件的监听函数hello，该函数只在冒泡阶段触发。 关于参数，有两个地方需要注意。 首先，第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象。 buttonElement.addEventListener('click', { handleEvent: function (event) { console.log('click'); } }); 上面代码中，addEventListener方法的第二个参数，就是一个具有handleEvent方法的对象。 其次，第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。 capture：布尔值，表示该事件是否在捕获阶段触发监听函数。 once：布尔值，表示监听函数是否只触发一次，然后就自动移除。 passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。 addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用removeEventListener方法手动去除）。 function hello() { console.log('Hello world'); } document.addEventListener('click', hello, false); document.addEventListener('click', hello, false); 执行上面代码，点击文档只会输出一行Hello world。 如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。 function print(x) { console.log(x); } var el = document.getElementById('div1'); el.addEventListener('click', function () { print('Hello'); }, false); 上面代码通过匿名函数，向监听函数print传递了一个参数。 监听函数内部的this，指向当前事件所在的那个对象。 // HTML 代码如下 // Hello var para = document.getElementById('para'); para.addEventListener('click', function (e) { console.log(this.nodeName); // \"P\" }, false); 上面代码中，监听函数内部的this指向事件所在的对象para。 1.2 EventTarget.removeEventListener() EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。 removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。 注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。 div.addEventListener('click', function (e) {}, false); div.removeEventListener('click', function (e) {}, false); 上面代码中，removeEventListener方法无效，因为监听函数不是同一个匿名函数。 element.addEventListener('mousedown', handleMouseDown, true); element.removeEventListener(\"mousedown\", handleMouseDown, false); 上面代码中，removeEventListener方法也是无效的，因为第三个参数不一样。 1.3 EventTarget.dispatchEvent() EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。 target.dispatchEvent(event) dispatchEvent方法的参数是一个Event对象的实例（详见《Event 对象》章节）。 para.addEventListener('click', hello, false); var event = new Event('click'); para.dispatchEvent(event); 上面代码在当前节点触发了click事件。 如果dispatchEvent方法的参数为空，或者不是一个有效的事件对象，将报错。 下面代码根据dispatchEvent方法的返回值，判断事件是否被取消了。 var canceled = !cb.dispatchEvent(event); if (canceled) { console.log('事件取消'); } else { console.log('事件未取消'); } 2. 监听函数 浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。 JavaScript 有三种方法，可以为事件绑定监听函数。 2.1 HTML 的 on- 属性 HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。 上面代码为body节点的load事件、div节点的click事件，指定了监听代码。一旦事件发生，就会执行这段代码。 元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。 注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。 使用这个方法指定的监听代码，只会在冒泡阶段触发。 一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。 使用这个方法指定的监听代码，只会在冒泡阶段触发。 点击 上面代码中，是的子元素。的click事件，也会触发的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。 直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。 el.setAttribute('onclick', 'doSomething()'); // 等同于 // 2.2 元素节点的事件属性 元素节点对象的事件属性，同样可以指定监听函数。 window.onload = doSomething; div.onclick = function (event) { console.log('触发事件'); }; 使用这个方法指定的监听函数，也是只会在冒泡阶段触发。 注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。 2.3 EventTarget.addEventListener() 所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。 window.addEventListener('load', doSomething, false); addEventListener方法的详细介绍，参见EventTarget章节。 2.4 小结 上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。 第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。 第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点： 同一个事件可以添加多个监听函数。 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。 除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。 3. this 的指向 监听函数内部的this指向触发事件的那个元素节点。 点击 执行上面代码，点击后会输出btn。 其他两种监听函数的写法，this的指向也是如此。 // HTML 代码如下 // 点击 var btn = document.getElementById('btn'); // 写法一 btn.onclick = function () { console.log(this.id); }; // 写法二 btn.addEventListener( 'click', function (e) { console.log(this.id); }, false ); 上面两种写法，点击按钮以后也是输出btn。 4. 事件的传播 一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。 第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。 第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。 这种三阶段的传播模型，使得同一个事件会在多个节点上触发。 点击 上面代码中，节点之中有一个节点。 如果对这两个节点，都设置click事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对点击，click事件会触发四次。 上面代码表示，click事件被触发了四次：节点的捕获阶段和冒泡阶段各1次，节点的目标阶段触发了2次。 捕获阶段：事件从向传播时，触发的click事件； 目标阶段：事件从到达时，触发的click事件； 冒泡阶段：事件从传回时，再次触发的click事件。 其中，节点有两个监听函数（addEventListener方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为click事件触发一次。所以，会在target阶段有两次输出。 注意，浏览器总是假定click事件的目标节点，就是点击位置嵌套最深的那个节点（本例是节点里面的节点）。所以，节点的捕获阶段和冒泡阶段，都会显示为target阶段。 事件传播的最上层对象是window，接着依次是document，html（document.documentElement）和body（document.body）。也就是说，上例的事件传播顺序，在捕获阶段依次为window、document、html、body、div、p，在冒泡阶段依次为p、div、body、html、document、window。 5. 事件的代理 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。 var ul = document.querySelector('ul'); ul.addEventListener('click', function (event) { if (event.target.tagName.toLowerCase() === 'li') { // some code } }); 上面代码中，click事件的监听函数定义在节点，但是实际上，它处理的是子节点的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。 如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。 // 事件传播到 p 元素后，就不再向下传播了 p.addEventListener('click', function (event) { event.stopPropagation(); }, true); // 事件冒泡到 p 元素后，就不再向上冒泡了 p.addEventListener('click', function (event) { event.stopPropagation(); }, false); 上面代码中，stopPropagation方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。 但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。 p.addEventListener('click', function (event) { event.stopPropagation(); console.log(1); }); p.addEventListener('click', function(event) { // 会触发 console.log(2); }); 上面代码中，p元素绑定了两个click事件的监听函数。stopPropagation方法只能阻止这个事件向其他元素传播。因此，第二个监听函数会触发。输出结果会先是1，然后是2。 如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。 p.addEventListener('click', function (event) { event.stopImmediatePropagation(); console.log(1); }); p.addEventListener('click', function(event) { // 不会被触发 console.log(2); }); 上面代码中，stopImmediatePropagation方法可以彻底阻止这个事件传播，使得后面绑定的所有click监听函数都不再触发。所以，只会输出1，不会输出2。 6. Event 对象概述 事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。 Event对象本身就是一个构造函数，可以用来生成新的实例。 event = new Event(type, options); Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。 bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。 cancelable：布尔值，可选，默认为false，表示事件是否可以被取消，即能否用Event.preventDefault()取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。 上面代码新建一个look事件实例，然后使用dispatchEvent方法触发该事件。 注意，如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。 // HTML 代码为 // Hello var div = document.querySelector('div'); var p = document.querySelector('p'); function callback(event) { var tag = event.currentTarget.tagName; console.log('Tag: ' + tag); // 没有任何输出 } div.addEventListener('click', callback, false); var click = new Event('click'); p.dispatchEvent(click); 上面代码中，p元素发出一个click事件，该事件默认不会冒泡。div.addEventListener方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成div.addEventListener('click', callback, true)，那么在“捕获阶段”可以监听到这个事件。 另一方面，如果这个事件在div元素上触发。 div.dispatchEvent(click); 那么，不管div元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时div元素是事件的目标，不存在是否冒泡的问题，div元素总是会接收到事件，因此导致监听函数生效。 7. Event 对象的实例属性 7.1 Event.bubbles，Event.eventPhase Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。 Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。 var phase = event.eventPhase; Event.eventPhase的返回值有四种可能。 0，事件目前没有发生。 1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。 2，事件到达目标节点，即Event.target属性指向的那个节点。 3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。 7.2 Event.cancelable，Event.cancelBubble，event.defaultPrevented Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。 大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。 var evt = new Event('foo'); evt.cancelable // false 当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。 如果事件不能取消，调用Event.preventDefault()会没有任何效果。所以使用这个方法之前，最好用Event.cancelable属性判断一下是否可以取消。 function preventEvent(event) { if (event.cancelable) { event.preventDefault(); } else { console.warn('This event couldn\\'t be canceled.'); console.dir(event); } } Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。 Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。 if (event.defaultPrevented) { console.log('该事件已经取消了'); } 7.3 Event.currentTarget，Event.target Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。 Event.target属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的Event.target与Event.currentTarget属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。 // HTML代码为 // Hello World function hide(e) { console.log(this === e.currentTarget); // 总是 true console.log(this === e.target); // 有可能不是 true e.target.style.visibility = 'hidden'; } para.addEventListener('click', hide, false); 上面代码中，如果在para节点的子节点上面点击，则e.target指向子节点，导致子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个para都将不可见。 7.4 Event.type Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。 var evt = new Event('foo'); evt.type // \"foo\" 7.5 Event.timeStamp Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。 var evt = new Event('foo'); evt.timeStamp // 3683.6999999995896 它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。 下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。 var previousX; var previousY; var previousT; window.addEventListener('mousemove', function(event) { if ( previousX !== undefined && previousY !== undefined && previousT !== undefined ) { var deltaX = event.screenX - previousX; var deltaY = event.screenY - previousY; var deltaD = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2)); var deltaT = event.timeStamp - previousT; console.log(deltaD / deltaT * 1000); } previousX = event.screenX; previousY = event.screenY; previousT = event.timeStamp; }); 7.6 Event.isTrusted Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个click事件，该事件是用户产生的；Event构造函数生成的事件，则是脚本产生的。 var evt = new Event('foo'); evt.isTrusted // false 上面代码中，evt对象是脚本产生的，所以isTrusted属性返回false。 7.7 Event.detail Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于click和dbclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。 // HTML 代码如下 // Hello function giveDetails(e) { console.log(e.detail); } document.querySelector('p').onclick = giveDetails; 8. Event 对象的实例方法 8.1 Event.preventDefault() Event.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的cancelable属性为true，如果为false，调用该方法没有任何效果。 注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用stopPropagation()或stopImmediatePropagation()方法。 // HTML 代码为 // var cb = document.getElementById('my-checkbox'); cb.addEventListener( 'click', function (e){ e.preventDefault(); }, false ); 上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。 利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。 // HTML 代码为 // var input = document.getElementById('my-input'); input.addEventListener('keypress', checkName, false); function checkName(e) { if (e.charCode 122) { e.preventDefault(); } } 上面代码为文本框的keypress事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。 8.2 Event.stopPropagation() stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。 function stopEvent(e) { e.stopPropagation(); } el.addEventListener('click', stopEvent, false); 上面代码中，click事件将不会进一步冒泡到el节点的父节点。 8.3 Event.stopImmediatePropagation() Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比Event.stopPropagation()更彻底。 如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了Event.stopImmediatePropagation方法，其他的监听函数就不会再执行了。 function l1(e){ e.stopImmediatePropagation(); } function l2(e){ console.log('hello world'); } el.addEventListener('click', l1, false); el.addEventListener('click', l2, false); 上面代码在el节点上，为click事件添加了两个监听函数l1和l2。由于l1调用了event.stopImmediatePropagation方法，所以l2不会被调用。 8.4 Event.composedPath() Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。 // HTML 代码如下 // // Hello // var div = document.querySelector('div'); var p = document.querySelector('p'); div.addEventListener('click', function (e) { console.log(e.composedPath()); }, false); // [p, div, body, html, document, Window] 上面代码中，click事件的最底层节点是p，向上依次是div、body、html、document、Window。 9. CustomEvent 接口 CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。 浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。 new CustomEvent(type, options) CustomEvent()构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。CustomEvent的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。 detail：表示事件的附带数据，默认为null。 下面是一个例子。 var event = new CustomEvent('build', { 'detail': 'hello' }); function eventHandler(e) { console.log(e.detail); } document.body.addEventListener('build', function (e) { console.log(e.detail); }); document.body.dispatchEvent(event); 上面代码中，我们手动定义了build事件。该事件触发后，会被监听到，从而输出该事件实例的detail属性（即字符串hello）。 下面是另一个例子。 var myEvent = new CustomEvent('myevent', { detail: { foo: 'bar' }, bubbles: true, cancelable: false }); el.addEventListener('myevent', function (event) { console.log('Hello ' + event.detail.foo); }); el.dispatchEvent(myEvent); 上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有detail属性。 10. 参考链接 Wilson Page, An Introduction To DOM Events Mozilla Developer Network, Using Firefox 1.5 caching Craig Buckler, How to Capture CSS3 Animation Events in JavaScript Ray Nicholus, You Don’t Need jQuery!: Events "},"技术笔记/行内元素、块级元素.html":{"url":"技术笔记/行内元素、块级元素.html","title":"行内元素、块级元素","keywords":"","body":"行内元素、块级元素 块级元素特点 总是在新行上开始，占据一整行 高度，行高以及外边距和内边距都可控制 宽度始终是与浏览器（父级）宽度一样，与内容无关 可以容纳行内元素和其他块级元素 行内元素特点 和其他行内元素都在一行上 高、行高及外边距和内边距部分可改变 宽度只与内容有关 行内元素能容纳文本或者其他行内元素 不可设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用 "},"技术笔记/重排和重绘.html":{"url":"技术笔记/重排和重绘.html","title":"重排和重绘","keywords":"","body":"重排(reflow)和重绘(repaint) 页面生成的过程： 1.HTML 被 HTML 解析器解析成 DOM 树； 2.CSS 被 CSS 解析器解析成 CSSOM 树； 3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment； 4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点； 5.将布局绘制(paint)在屏幕上，显示出整个页面。 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。 渲染： 在页面的生命周期中，网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。 重排比重绘大： 大，在这个语境里的意思是：谁能影响谁？ 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。 也就是说：重绘不一定导致重排，但重排一定会导致重绘。 "},"技术笔记/async await为什么可以捕获Promise内部异常.html":{"url":"技术笔记/async await为什么可以捕获Promise内部异常.html","title":"async await为什么可以捕获Promise内部异常","keywords":"","body":"async await 为什么可以捕获到Promise内部异常 源代码vs编译后的代码 源代码如下： async function test() { try { await Promise.reject('bad'); } catch (err) { console.log(err); } } 编译后的代码如下： function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err); } _next(undefined); }); }; } function test() { return _test.apply(this, arguments); } function _test() { _test = _asyncToGenerator(function* () { try { yield Promise.reject('bad'); } catch (err) { console.log(err); } }); return _test.apply(this, arguments); } 逐步分析： 函数执行，实际上执行_asyncToGenerator返回的函数，_asyncToGenerator传入的fn为一个迭代器 asyncToGenerator返回的函数，返回了一个Promise，并开始递归执行fn迭代器 当yield 返回一个fullfilled的Promise时，会调用_next方法，当返回一个rejected的Promise时，会调用_throw方法 当调用_throw方法时，会调用迭代器的throw方法抛出一个异常，这个异常会先被迭代器内部的try catch捕获，即我们代码写的try catch "},"技术笔记/css揭秘笔记.html":{"url":"技术笔记/css揭秘笔记.html","title":"css揭秘笔记","keywords":"","body":"[TOC] 第一章 Web标准：是敌还是友 浏览器前缀 每个浏览器都可以实现 这些实验性的(甚至是私有的、非标准的)特性，但要在名称前面加上自 己特有的前缀。 只是给开发者尝试的新特性，如果后续被采用，是不需要使用带前缀的特性的。但是浏览器前缀被滥用，导致很多特性都加上了浏览器后缀，加大了维护成本。 目前的解决方案：这些实验性特性需要通过配置开关来启用，这可以有效防止开 发者在生产环境中使用它们，因为你不能要求用户为了正确地浏览你的网站 而去修改浏览器设置 第二章 背景和边框 1、半透明边框 通常我们都是在background属性使用rgba()和hsla()，但是在边框中使用半透明颜色时，会发现边框背后会有背景色，如下： border: 10px solid hsla(0,0%,100%,.5); background: white; 解决方案： ​ 在 CSS 2.1 中，这就是背景的工作原理。我们只能接受它并且向前看。 谢天谢地，从背景与边框(第三版)(http://w3.org/TR/css3-background)开 始，我们可以通过 background-clip 属性来调整上述默认行为所带来的不 便。这个属性的初始值是 border-box，意味着背景会被元素的 border box(边框的外沿框)裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为 padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。 即background默认包含border的位置，修改代码如下就可解决： border: 10px solid hsla(0,0%,100%,.5); background: white; background-clip: padding-box; 2、多重边框 box-shadow 方案 box-shadow: h-shadow v-shadow blur spread color inset; 如上，box-shadow接受第四个参数扩张半径，通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加 上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框，如图： background: yellowgreen; box-shadow: 0 0 0 10px #655; 这样，我们就可以利用box-shadow的逗号分隔语法，设置任意数量的投影： background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink; 唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。如果你愿意，甚至还可以在这些“边框”的底下再加一 层常规的投影: background: yellowgreen; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); 多重投影解决方案在绝大多数场合都可以很好地工作，但有一些注意事项。 投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会 受到 box-sizing 属性的影响。不过，你还是可以通过内边距或外边距(这取决于投影是内嵌和还是外扩的)来额外模拟出边框所需要占据的空间。 上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响 应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给 box-shadow属性加上inset关键字，来使投影绘制在元素的内圈。 请注意，此时你需要增加额外的内边距来腾出足够的空隙。 outline 方案 在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边 框，再加上 outline(描边)属性来产生外层的边框。这种方法的一大优 点在于边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框(假设我们需要产生虚线边框效果，box-shadow 就没辙了)。 background: yellowgreen; border: 10px solid #655; outline: 5px solid deeppink; 描边的另一个好处在于，你可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性甚至可以接受负值。这对于某些效果来说非 常有用，如下： background: yellowgreen; border: 10px solid #655; outline: 5px dashed #fff; outline-offset: -10px; 这个方案同样也有一些需要注意的地方： 如上所述，它只适用于双层“边框”的场景，因为 outline 并不能 接受用逗号分隔的多个值。如果我们需要获得更多层的边框，前一 种方案就是我们唯一的选择了。 边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素 是圆角的，它的描边可能还是直角的。请注意，这种行 为被 CSS 工作组认为是一个 bug，因此未来可能会改为贴合 border- radius 圆角。 根据 CSS 基本 UI 特性(第三版)规范(http://w3.org/TR/css3-ui)所 述，“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形 的，但如果你想使用这个方法，请切记:最好在不同浏览器中完整 地测试最终效果。 3、灵活的背景定位 background-position 的扩展语法 在 CSS 背景与边框(第三版)(http://w3.org/TR/css3-background)中， background-position 属性已经得到扩展，它允许我们指定背景图片距离任 意角的偏移量，只要我们在偏移量前面指定关键字。举例来说，如果想让背 景图片跟右边缘保持 20px 的偏移量，同时跟底边保持 10px 的偏移量，可以这样做: Tip: background-size: contain 代表图片缩放至全部显示在背景上。background-size: cover 代表图片缩放至整个覆盖背景。 background: url(code-pirate.svg) no-repeat #58a; background-position: right 20px bottom 10px; 最后一步，我们还需要提供一个合适的回退方案。因为对上述方案来 说，在不支持 background-position 扩展语法的浏览器中，背景图片会紧 贴在左上角(背景图片的默认位置)。这看起来会很奇怪，而且它会干扰到 文字的可读性。提供一个回退方案也很简单，就是把老套的 bottom right 定位值写进 background 的简写属性中: background: url(code-pirate.svg) no-repeat bottom right #58a; background-position: right 20px bottom 10px; background-origin 在给背景图片设置距离某个角的偏移量时，有一种情况极其常见:偏移 量与容器的内边距一致。如果采用上面提到的 background-position 的扩 展语法方案，代码看起来会是这样的: padding: 10px; background: url(code-pirate.svg) no-repeat #58a; background-position: right 10px bottom 10px; 但是每次改动内边距的值时，我们都需要在三个地方更新这个值。 background-origin在默认情况下，它的值是padding-box。如果把它的值改成 content-box(参见下面的代码)，我们在 background-position 属 性中使用的边角关键字将会以内容区的边缘作为基准(也就是说，此时背景 图片距离边角的偏移量就跟内边距保持一致了): padding: 10px; background: url(\"code-pirate.svg\") no-repeat #58a bottom right; /* 或 100% 100% */ background-origin: content-box; calc() 把背景图片定位到距离底边 10px 且 距离右边 20px 的位置。如果我们仍然以左上角偏移的思路来考虑，其实 就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直 偏移量。calc() 函数允许我们执行此类运算，它可以完美地在 background-position 属性中使用: background: url(\"code-pirate.svg\") no-repeat; background-position: calc(100% - 20px) calc(100% - 10px); 4、边框内圆角 有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外 部仍然保持直角的形状，如图 2-15 所示。这是一个有趣的效果，目前还没 有被滥用。用两个元素可以实现这个效果，这并没有什么特别的: 相关规范 图 2-15 容器外围有一道边框，但只在内 侧有圆角 I have a nice subtle inner rounding, don't I look pretty? ```html I have a nice subtle inner rounding, don't I look pretty? .something-meaningful { background: #655; padding: .8em; } .something-meaningful > div { background: tan; border-radius: .8em; padding: 1em; } 这个方法很好，但要求我们使用两个元素，而我们只需要一个元素。有 没有办法可以只用一个元素达成同样的效果呢?（用box-shadow覆盖圆角旁空余部分颜色） ```css background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .6em red; outline: .6em solid #655; 5、条纹背景 假设我们有一条基本的垂直线性渐变，颜色从#fb3 过渡到#58a background: linear-gradient(#fb3, #58a); 现在，让我们试着把这两个色标拉近一点: background: linear-gradient(#fb3 20%, #58a 80%); 如果我们把两个色标重合在一起， 会发生什么? background: linear-gradient(#fb3 50%, #58a 50%); “如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域， 过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那 个位置突然变化，而不是一个平滑的渐变过程。” 如上图所示，已经没有任何渐变效果了，只有两块实色， 各占据了 background-image 一半的面积。本质上，我们已经创建了两条巨 大的水平条纹。 因为渐变是一种由代码生成的图像，我们能像对待其他任何背景图像那 样对待它，而且还可以通过 background-size 来调整其尺寸: background: linear-gradient(#fb3 50%, #58a 50%); background-size: 100% 30px; 在图 2-24 中可以看到，我们把这两条条纹的高度都缩小到了 15px。由 于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹 (参见图 2-25)。我们还可以用相同的方法来创建不等宽的条纹，只需调整色标的位置值 即可: background: linear-gradient(#fb3 30%, #58a 30%); background-size: 100% 30px; 为了避免每次改动条纹宽度时都要修改两个数字，我们可以再次从规范 那里找到捷径。 “如果某个色标的位置值比整个列表中在它之前的色标的位置值都要 小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。” 这意味着，如果我们把第二个色标的位置值设置为 0，那它的位置就 总是会被浏览器调整为前一个色标的位置值，这个结果正是我们想要的。 因此，下面的代码会产生跟上图 完全一样的条纹背景，但代码会更加 DRY: background: linear-gradient(#fb3 30%, #58a 0); background-size: 100% 30px; 如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代 码可以生成三种颜色的水平条纹: background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0); background-size: 100% 45px; 垂直条纹 水平条纹是最容易用代码写出来的，但我们在网页上看到的条纹图案并 不都是水平的。有些条纹是垂直的(参见图 2-28)，而且某些形态的斜条纹 或许更受欢迎，或者看起来更加有趣。幸运的是，CSS 渐变同样也能帮助我 们创建出这些效果，只是难度稍有不同。 垂直条纹的代码跟水平条纹几乎是一样的，差别主要在于:我们需要在 开头加上一个额外的参数来指定渐变的方向。在水平条纹的代码中，我们其 实也可以加上这个参数，只不过它的默认值to bottom本来就跟我们的意 图一致，于是就省略了。最后，我们还需要把 background-size 的值颠倒 一下，原因应该不用多说了吧: background: linear-gradient(to right, /* 或 90deg */ #fb3 50%, #58a 0); background-size: 30px 100%; 斜向条纹 在完成了水平和垂直条纹之后，我们可能会顺着往下想:如果我们再次 改变 background-size 的值和渐变的方向，是不是就可以得到斜向(比如 45°)的条纹图案呢?比如这样(结果如图 2-29 所示): background: linear-gradient(45deg,#fb3 50%, #58a 0); background-size: 30px 30px; 可以发现，这个办法行不通。原因在于我们只是把每个“贴片”1 1内部的 渐变旋转了 45°，而不是把整个重复的背景都旋转了。试着回忆一下我们以 前用位图来生成斜向条纹时是怎么做的吧，做法类似图 2-30。单个贴片包 含了四条条纹，而不是两条，只有这样才有可能做到无缝拼接。它正是我们 需要在 CSS 代码中重新实现的贴片，因此我们需要增加一些色标: background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0); background-size: 30px 30px; 更好的斜向条纹 在前面的段落中展示的方法还不够灵活。假设我们想让条纹不是 45°而是 60°怎么办?或者是 30°?又或者是 3.141 592 653 5°?如果我们只是把渐 变的角度改一下，那么结果看起来会相当糟糕。(比如在图 2-34 中，我们尝 试实现 60°条纹，但以失败告终。) 幸运的是，我们还有更好的方法来创建斜向条纹。一个鲜为人知的真 相是 linear-gradient() 和 radial-gradient() 还各有一个循环式的加强 版:repeating-linear-gradient() 和 repeating-radial-gradient()。它们的工作方式跟前两者类似，只有一点不同:色标是无限循环重复的，直到填满整个背景。下面是一个重复渐变的例子(效果参见图 2-35): background: repeating-linear-gradient(45deg, #fb3, #58a 30px); 它相当于下面这个简单的线性渐变: background: linear-gradient(45deg, #fb3, #58a 30px, #fb3 30px, #58a 60px, #fb3 60px, #58a 90px, #fb3 90px, #58a 120px, #fb3 120px, #58a 150px, ...); 重复线性渐变完美适用于——你已经猜到了吧——条纹效果!这得益于 它们可以无限循环的天赋，一个渐变图案就可自动重复并铺满整个背景。因 此，我们再也不需要去操心如何创建出可以无缝拼接的贴片了。 我们苦苦追寻的 60°条纹只需这样写即可: background: repeating-linear-gradient(60deg, #fb3, #fb3 15px, #58a 0, #58a 30px); 灵活的同色系条纹 在大多数情况下，我们想要的条纹图案并不是由差异极大的几种颜色组 成的，这些颜色往往属于同一色系，只是在明度方面有着轻微的差异。举个 例子，我们来看看这个条纹图案: background: repeating-linear-gradient(30deg, #79b, #79b 15px, #58a 0, #58a 30px); 在图 2-37 中可以看到，条纹是由一个主色调( 变体所组成的。但是，这两种颜色之间的关系在代码中并没有体现出来。此 外，如果我们想要改变这个条纹的主色调，甚至需要修改四处! 幸运的是，还有一种更好的方法:不再为每种条纹单独指定颜色，而是 把最深的颜色指定为背景色，同时把半透明白色的条纹叠加在背景色之上来 得到浅色条纹: background: #58a; background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px); 6、复杂的背景图案 网格 只使用一个渐变时，我们能创建的图案并不多。当我们把多个渐变图 案组合起来，让它们透过彼此的透明区域显现时，神奇的事情就发生了。按 照这个思路，我们首先想到的可能就是把水平和垂直的条纹叠加起来，从而 得到各种样式的网格。举例来说，下面的代码会创建如图 2-39 所示的桌布(方格纹)图案。 background: white; background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 0), linear-gradient( rgba(200,0,0,.5) 50%, transparent 0); background-size: 30px 30px; 在某些情况下，我们希望网格中每个格子的大小可以调整，而网格线条 的粗细同时保持固定。举例来说，类似图纸辅助线的网格就是这种情况。这 是一个非常好的例子，展示了使用长度而不是百分比作为色标的场景: background: #58a; background-image: linear-gradient(white 1px, transparent 0), linear-gradient(90deg, white 1px, transparent 0); background-size: 30px 30px; 我们得到的结果就是一幅用 1px 白线画出来的 30px 大小的网格图案 (参见图 2-40)。与“灵活的同色系条纹”一节中的例子类似，主色调在这 里也起到了回退颜色的作用。 利用这个还可以实现更多的效果： 7、伪随机背景 为了更真实地模拟条纹的随机性，我们接下来可能会想到，把这组条纹 从一个平面拆散为多个图层:一种颜色作为底色，另三种颜色作为条纹，然 后再让条纹以不同的间隔进行重复平铺。这一点不难做到，我们在色标中定 好条纹的宽度，再用 background-size 来控制条纹的间距。代码看起来可 能是这样的: background: hsl(20, 40%, 90%); background-image: linear-gradient(90deg, #fb3 10px, transparent 0), linear-gradient(90deg, #ab4 20px, transparent 0), linear-gradient(90deg, #655 20px, transparent 0); background-size: 80px 100%, 60px 100%, 40px 100%; 因为最顶层贴片1 1 我们应该把平铺间距最大的贴片安排在最顶层(在我们的例子中是橙色条 纹)。 在图 2-54 中可以看到，这样的结果显明更有随机的感觉;但如果仔细 观察的话，仍然可以看出图案每隔 240px 就会重复一次。这个组合图案中第 一个贴片的终点，就是各层背景图像以不同间距重复数次后再次统一对齐的 点。让我们再次穿越回初中数学课堂:如果我们有一些数字，那么可以同时 整除所有数字的最小数字就叫作它们的最小公倍数(LCM)。因此，这里贴 片的尺寸实际上就是所有 background-size 的最小公倍数，而 40、60 和 80 的最小公倍数正是 240。 根据这个逻辑，要让这种随机性更加真实，我们得把贴片的尺寸最大 化。感谢数学，我们不需要苦苦思索如何做到这一点，因为我们已经知道答 案了。为了让最小公倍数最大化，这些数字最好是“相对质数”11。在这种情 况下，它们的最小公倍数就是它们的乘积。举例来说，3、4 和 5 是相对质 数，因此它们的最小公倍数就是 3×4×5=60。要达成相对质数，最简单的办 法就是尽量选择质数，因为质数跟其他任意数字都是相对质数。在网上可以 找到质数的清单，它们有的非常大。 为了进一步增加随机性，我们甚至可以用质数来指定各组条纹的宽度。 于是我们的代码变为: background: hsl(20, 40%, 90%); background-image: linear-gradient(90deg, #fb3 11px, transparent 0), linear-gradient(90deg, #ab4 23px, transparent 0), linear-gradient(90deg, #655 41px, transparent 0); background-size: 41px 100%, 61px 100%, 83px 100%; 8 连续的图像边框 参照：https://blog.csdn.net/qq_41903941/article/details/90259306 第三章 9、自适应的椭圆 给任何正方形元素设置一个足够大的border- radius，就可以把它变成一个圆形。所用到的 CSS 代码如下所示: background: #fb3; width: 200px; height: 200px; border-radius: 100px; /* >= 正方形边长的一半 */ 你可能还注意到了，如果指定任何大于 100px 的半径，仍然可以得到一 个圆形。规范特别指出了这其中的原因: “当任意两个相邻圆角的半径之和超过 border box 的尺寸时，用户 代理必须按比例减小各个边框半径所使用的值，直到它们不会相互重叠 为止。” 说到 border-radius，有一个鲜为人知的真相:它可以单独指定水平 和垂直半径，只要用一个斜杠(/)分隔这两个值即可。这个特性允许我 们在拐角处创建椭圆圆角(参见图 3-3)。因此，如果我们有一个尺寸为 200px×150px 的元素，就可以把它圆角的两个半径值分别指定为元素宽高的 一半，从而得到一个精确的椭圆: border-radius: 100px / 75px; "},"技术笔记/http2.0.html":{"url":"技术笔记/http2.0.html","title":"http2.0","keywords":"","body":"HTTP 2.0 多路复用——得益于二进制分帧，多个请求同时复用同一个连接 头部压缩——第一次请求两端缓存头部，后续请求只发送差异头部 服务器推送——请求HTML时，服务器可以主动推送HTML中需要的资源，减少加载时间 "},"技术笔记/https.html":{"url":"技术笔记/https.html","title":"https","keywords":"","body":"HTTPS ssl建立连接过程 客户端请求https地址，发送客户端支持的加密算法 服务端收到消息后，响应匹配好的加密算法和数字证书（公钥） 客户端解析证书，并生成一个随机值（会话密钥） 客户端通过公钥加密会话密钥 客户端向服务端发送4的加密信息 服务端解密获得会话密钥并响应成功 客户端通过会话密钥加密一条消息并发送给服务端，验证服务端是否正常接收加密消息 服务端回传一条通过会话密钥加密的消息，客户端接收的话表明ssl连接建立完成了 "},"技术笔记/js使用技巧.html":{"url":"技术笔记/js使用技巧.html","title":"js使用技巧","keywords":"","body":"1.生成指定范围的数字 在某些情况下，我们会创建一个处在两个数之间的数组。假设我们要判断某人的生日是否在某个范围的年份内，那么下面是实现它的一个很简单的方法 😎 let start = 1900, end = 2000; [...new Array(end + 1).keys()].slice(start); // [ 1900, 1901, ..., 2000] // 还有这种方式，但对于很的范围就不太稳定 Array.from({ length: end - start + 1 }, (_, i) => start + i); 2.使用值数组作为函数的参数 在某些情况下，我们需要将值收集到数组中，然后将其作为函数的参数传递。 使用 ES6，可以使用扩展运算符(...)并从[arg1, arg2] > (arg1, arg2)中提取数组: const parts = { first: [0, 2], second: [1, 3], } [\"Hello\", \"World\", \"JS\", \"Tricks\"].slice(...parts.second) // [\"World\", \"JS\"] 复制代码 3.将值用作 Math 方法的参数 当我们需要在数组中使用Math.max或Math.min来找到最大或者最小值时，我们可以像下面这样进行操作： const elementsHeight = [...document.body.children].map( el => el.getBoundingClientRect().y ); Math.max(...elementsHeight); // 474 const numbers = [100, 100, -1000, 2000, -3000, 40000]; Math.min(...numbers); // -3000 复制代码 4.合并/展平数组中的数组 Array 有一个很好的方法，称为Array.flat，它是需要一个depth参数，表示数组嵌套的深度，默认值为1。 但是，如果我们不知道深度怎么办，则需要将其全部展平，只需将Infinity作为参数即可 😎 const arrays = [[10], 50, [100, [2000, 3000, [40000]]]] arrays.flat(Infinity) // [ 10, 50, 100, 2000, 3000, 40000 ] 复制代码 5. 防止代码崩溃 在代码中出现不可预测的行为是不好的，但是如果你有这种行为，你需要处理它。 例如，常见错误TypeError，试获取undefined/null等属性，就会报这个错误。 const found = [{ name: \"Alex\" }].find(i => i.name === 'Jim') console.log(found.name) // TypeError: Cannot read property 'name' of undefined 复制代码 我们可以这样避免它： const found = [{ name: \"Alex\" }].find(i => i.name === 'Jim') || {} console.log(found.name) // undefined 复制代码 6. 传递参数的好方法 对于这个方法，一个很好的用例就是styled-components，在ES6中，我们可以将模板字符中作为函数的参数传递而无需使用方括号。 如果要实现格式化/转换文本的功能，这是一个很好的技巧： const makeList = (raw) => raw .join() .trim() .split(\"\\n\") .map((s, i) => `${i + 1}. ${s}`) .join(\"\\n\"); makeList` Hello, World Hello, World `; // 1. Hello,World // 2. World,World 复制代码 7.交换变量 使用解构赋值语法，我们可以轻松地交换变量 使用解构赋值语法 😬: let a = \"hello\" let b = \"world\" // 错误的方式 a = b b = a // { a: 'world', b: 'world' } // 正确的做法 [a, b] = [b, a] // { a: 'world', b: 'hello' } 复制代码 8.按字母顺序排序 需要在跨国际的项目中，对于按字典排序，一些比较特殊的语言可能会出现问题，如下所示 😨 // 错误的做法 [\"a\", \"z\", \"ä\"].sort((a, b) => a - b); // ['a', 'z', 'ä'] // 正确的做法 [\"a\", \"z\", \"ä\"].sort((a, b) => a.localeCompare(b)); // [ 'a', 'ä', 'z' ] 复制代码 localeCompare() :用本地特定的顺序来比较两个字符串。 9.隐藏隐私 最后一个技巧是屏蔽字符串,当你需要屏蔽任何变量时(不是密码)，下面这种做法可以快速帮你做到： const password = \"hackme\"; password.substr(-3).padStart(password.length, \"*\"); // ***kme 复制代码 代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 Fundebug。 "},"技术笔记/markdown.html":{"url":"技术笔记/markdown.html","title":"markdown","keywords":"","body":"Markdown 语法学习 [TOC] 1、快捷键 功能 快捷键 加粗 Ctrl+B 斜体 Ctrl+I 引用 Ctrl+Q 插入链接 Ctrl+L 插入代码 Ctrl+K 插入图片 Ctrl+G 提升标题 Ctrl+H 有序列表 Ctrl+O 无序列表 Ctrl+U 横线 Ctrl+R 撤销 Ctrl+Z 重做 Ctrl+Y 2、基本语法 2.1 字体设置斜体粗体删除线 正常文字 这里是文字 这里是文字 这里是文字 这里是文字 这里是文字 2.2 分级标题 写法1: # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这个写法和 文字效果是一样的 写法2： 这是一个一级标题 或者 二级标题 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 2.3 链接 插入本地图片链接 语法规则，有两种写法： 插入互联网上图片 语法规则： 自动连接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来， Markdown 就会自动把它转成链接。也可以直接写，也是可以显示成链接形式的 例如：http://www.baidu.com 2.4 分割线 你可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 2.5 代码块 对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“`”符号（一般在ESC键下方，和~同一个键）包裹代码。 （1）代码块：缩进 4 个空格或是 1 个制表符。效果如下： function test() { } 2）行内式：如果在一个行内需要引用代码，只要用反引号`引起来就好（一般在ESC键下方，和~同一个键） （3）多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹，就可以了。 示例如下 （4）代码块里面包含html代码 在代码区块里面， & 、 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。 注意：简书代码块里不支持html。 示例如下： 2.6 引用 在被引用的文本前加上>符号，以及一个空格就可以了，如果只输入了一个>符号会产生一个空白的引用。 （1）基本使用 使用如下图所示： （2）引用的嵌套使用 使用如图所示： （3）引用其它要素 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 使用如图所示： 2.7 列表 （1）无序列表 使用 *，+，- 表示无序列表。 注意：符号后面一定要有一个空格，起到缩进的作用。 （2）有序列表 使用数字和一个英文句点表示有序列表。 注意：英文句点后面一定要有一个空格，起到缩进的作用。 （3）无序列表和有序列表同时使用 （4）列表和其它要素混合使用 列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。 注意事项： （1）加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。 （2）列表中包含代码块（前面加2个tab或者8个空格，并且需要空一行，否则不显示）。 使用示例如下图： （5）注意事项 在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\\就可以了。如下图所示： 2.8 表格 表格的基本写法很简单，就跟表格的形状很相似： 表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 3、常用技巧 3.1 换行 方法1: 连续两个以上空格+回车 方法2：使用html语言换行标签： 3.2 缩进字符 不断行的空白格 或 半角的空格   或  全角的空格   或 3.3 特殊符号 （1）对于 Markdown 中的语法符号，前面加反斜线\\即可显示符号本身。 示例如下： （2）其他特殊字符，示例如下： 想知道字符对应的Unicode码，可以看这个网站：https://unicode-table.com/cn/ 附上几个工具对特殊字符的支持的对比图: 3.4 字体、字号与颜色 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！ CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。 字体，字号和颜色编辑如下代码 具体颜色分类及标记请看下表： 3.5 链接的高级操作 链接的高级操作（这个需要掌握一下，很有用） 1.行内式 这个在上文第二条基本语法的 链接这个小节已经过，这里就不继续讲解了。 2.参考式链接 在文档要插入图片的地方写![图片或网址链接][标记]，在文档的最后写上[标记]:图片地址 “标题”。（最后这个”标题”可以不填写） 示例如下： 3.内容目录 在段落中填写 [TOC] 以显示全文内容的目录结构。 4.锚点 锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。 注意：在简书中使用锚点时，点击会打开一个新的当前页面，虽然锚点用的不是很舒服，但是可以用注脚实现这个功能。 语法说明： 在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。 使用如下图所示： 5.注脚 语法说明： 在需要添加注脚的文字后加上脚注名字注脚名字,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 示例如下： 注： 脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。 由于简书不支持锚点，所以可以用注脚实现页面内部的跳转。 3.6 背景色 Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下： 背景色是：orange 3.7 emoji表情符号 emoji表情使用:EMOJICODE:的格式，详细列表可见 https://www.webpagefx.com/tools/emoji-cheat-sheet/ 当然现在很多markdown工具或者网站都不支持。 下面列出几个平台的对比： 工具或网站 是否支持emoji表情符号 简书 否 MarkDownPad 否（不知道付费版是否支持） 有道云笔记 否 zybuluo.com 否 github 是 4. 高端用法 4.1 Latex数学公式 使用LaTex数学公式 1.行内公式：使用两个”$”符号引用公式: $公式$ 2.行间公式：使用两对“$$”符号引用公式： $$公式$$ 输入$\\sqrt{x^{2}}$ 显示结果是x2‾‾√x2 具体可以参考 markdown编辑器使用LaTex数学公式（https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Ftestcs_dn%2Farticle%2Fdetails%2F44229085） latex数学符号详见：常用数学符号的 LaTeX 表示方法 4.2 流程图 这里简单介绍一下流程图的语法，仅作为了解，如下图所示： 4.3 制作一份待办事宜—-Todo 列表 4.4 绘制 序列图 4.5 绘制 甘特图 5. Markdown工具 1.markdownpad软件，就是利用markdown语言写笔记的。官网下载地址：http://markdownpad.com/ 软件安装之后的示意图如下图所示： 2.有道云笔记支持markdownpad语法。官方网址：http://note.youdao.com/ 它有在线网页版以及PC端可以下载。当然有道云笔记也支持html语法。 网页版使用markdown示例图如下： 3.在线编辑markdown https://www.zybuluo.com/mdeditor 本文参考文章： http://blog.csdn.net/u010177286/article/details/50358720 https://www.zybuluo.com/mdeditor http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-18 "},"技术笔记/react hook 原理.html":{"url":"技术笔记/react hook 原理.html","title":"react hook 原理","keywords":"","body":"react hook 原理 摘要 当使用 Hook 特性编写组件的时候时候，总能感觉到它的简洁和方便。当然，「天下没有免费的午餐」，它牺牲了可读性并且存在内存泄漏风险（最后有提到）。但这并不妨碍探索它的魔力。 在正式开始前，希望您读过 Hook 的文档或者在项目使用过它。但如果只对函数编程感兴趣，也可能有所收获。 为了让行文更流畅，我打算先抛出几个问题，这些问题会在源码实现的过程中，逐步解决： 🤔️ useState 的实现原理 🤔️ 为什么不能在循环、判断内部使用 Hook 🤔️ useEffect 的实现原理 🤔️ useEffect 的应用场景 🤔️ Class vs Hooks useState 的实现原理 当调用 useState 的时候，会返回形如 (变量, 函数) 的一个元祖。并且 state 的初始值就是外部调用 useState 的时候，传入的参数。 理清楚了传参和返回值，再来看下 useState 还做了些什么。正如下面代码所示，当点击按钮的时候，执行setNum，状态 num 被更新，并且 UI 视图更新。显然，useState 返回的用于更改状态的函数，自动调用了render方法来触发视图更新。 function App() { const [num, setNum] = useState 0; return ( num: {num} setNum(num + 1)}>加 1 ); } 有了上面的探索，借助闭包，封装一个 setState 如下： function render() { ReactDOM.render(, document.getElementById(\"root\")); } let state: any; function useState(initialState: T): [T, (newState: T) => void] { state = state || initialState; function setState(newState: T) { state = newState; render(); } return [state, setState]; } render(); // 首次渲染 先不要考虑题目提及的问题。思路还是回到如何让 useState 支持多个 state。《React hooks: not magic, just arrays》中提及，React Hook 看起来非常 Magic 的实现，本质上还是通过 Array 来实现的。 前面 useState 的简单实现里，初始的状态是保存在一个全局变量中的。以此类推，多个状态，应该是保存在一个专门的全局容器中。这个容器，就是一个朴实无华的 Array 对象。具体过程如下： 第一次渲染时候，根据 useState 顺序，逐个声明 state 并且将其放入全局 Array 中。每次声明 state，都要将 cursor 增加 1。 更新 state，触发再次渲染的时候。cursor 被重置为 0。按照 useState 的声明顺序，依次拿出最新的 state 的值，视图更新。 请看下面这张图，每次使用 useState，都会向 STATE 容器中添加新的状态。 实现的代码如下： import React from \"react\"; import ReactDOM from \"react-dom\"; const states: any[] = []; let cursor: number = 0; function useState(initialState: T): [T, (newState: T) => void] { const currenCursor = cursor; states[currenCursor] = states[currenCursor] || initialState; // 检查是否渲染过 function setState(newState: T) { states[currenCursor] = newState; render(); } ++cursor; // update: cursor return [states[currenCursor], setState]; } function App() { const [num, setNum] = useState 0; const [num2, setNum2] = useState 1; return ( num: {num} setNum(num + 1)}>加 1 setNum(num - 1)}>减 1 num2: {num2} setNum2(num2 * 2)}>扩大一倍 setNum2(num2 / 2)}>缩小一倍 ); } function render() { ReactDOM.render(, document.getElementById(\"root\")); cursor = 0; // 重置cursor } render(); // 首次渲染 此时，如果想在循环、判断等不在函数组件顶部的地方使用 Hook，如下所示： let tag = true; function App() { const [num, setNum] = useState 0; // 只有初次渲染，才执行 if (tag) { const [unusedNum] = useState 1; tag = false; } const [num2, setNum2] = useState 2; return ( num: {num} setNum(num + 1)}>加 1 setNum(num - 1)}>减 1 num2: {num2} setNum2(num2 * 2)}>扩大一倍 setNum2(num2 / 2)}>缩小一倍 ); } 由于在条件判断的逻辑中，重置了tag=false，因此此后的渲染不会再进入条件判断语句。看起来好像没有问题？但是，由于 useState 是基于 Array+Cursor 来实现的，第一次渲染时候，state 和 cursor 的对应关系如下表： 变量名 cursor num 0 unusedNum 1 num2 2 当点击事件触发再次渲染，并不会进入条件判断中的 useState。所以，cursor=2 的时候对应的变量是 num2。而其实 num2 对应的 cursor 应该是 3。就会导致setNum2并不起作用。 到此，解决了文章开头提出的「🤔️ 为什么不能在循环、判断内部使用 Hook」。在使用 Hook 的时候，请在函数组件顶部使用！ useEffect 的实现原理 在探索 useEffect 原理的时候，一直被一个问题困扰：useEffect 作用和用途是什么？当然，用于函数的副作用这句话谁都会讲。举个例子吧： function App() { const [num, setNum] = useState(0); useEffect(() => { // 模拟异步请求后端数据 setTimeout(() => { setNum(num + 1); }, 1000); }, []); return {!num ? \"请求后端数据...\" : `后端数据是 ${num}`}; } 复制代码 这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。但这并不是必要的。完全可以不使用useEffect，直接使用setTimeout，并且它的回调函数中更新函数组件的 state。 这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。但这并不是必要的。完全可以不使用useEffect，直接使用setTimeout，并且它的回调函数中更新函数组件的 state。 在阅读A Complete Guide to useEffect和构建你自己的 Hooks之后，我才理解 useEffect 的存在的必要性和意义。 在 useEffect 的第二个参数中，我们可以指定一个数组，如果下次渲染时，数组中的元素没变，那么就不会触发这个副作用（可以类比 Class 类的关于 nextprops 和 prevProps 的生命周期）。好处显然易见，相比于直接裸写在函数组件顶层，useEffect 能根据需要，避免多余的 render。 下面是一个不包括销毁副作用功能的 useEffect 的 TypeScript 实现： // 还是利用 Array + Cursor的思路 const allDeps: any[][] = []; let effectCursor: number = 0; function useEffect(callback: () => void, deps: any[]) { if (!allDeps[effectCursor]) { // 初次渲染：赋值 + 调用回调函数 allDeps[effectCursor] = deps; ++effectCursor; callback(); return; } const currenEffectCursor = effectCursor; const rawDeps = allDeps[currenEffectCursor]; // 检测依赖项是否发生变化，发生变化需要重新render const isChanged = rawDeps.some( (dep: any, index: number) => dep !== deps[index] ); if (isChanged) { callback(); allDeps[effectCursor] = deps; // 感谢 juejin@carlzzz 的指正 } ++effectCursor; } function render() { ReactDOM.render(, document.getElementById(\"root\")); effectCursor = 0; // 注意将 effectCursor 重置为0 } 对于 useEffect 的实现，配合下面案例的使用会更容易理解。当然，你也可以在这个 useEffect 中发起异步请求，并在接受数据后，调用 state 的更新函数，不会发生爆栈的情况。 function App() { const [num, setNum] = useState 0; const [num2] = useState 1; // 多次触发 // 每次点击按钮，都会触发 setNum 函数 // 副作用检测到 num 变化，会自动调用回调函数 useEffect(() => { console.log(\"num update: \", num); }, [num]); // 仅第一次触发 // 只会在compoentDidMount时，触发一次 // 副作用函数不会多次执行 useEffect(() => { console.log(\"num2 update: \", num2); }, [num2]); return ( num: {num} setNum(num + 1)}>加 1 setNum(num - 1)}>减 1 ); } ⚠️ useEffect 第一个回调函数可以返回一个用于销毁副作用的函数，相当于 Class 组件的 unmount 生命周期。这里为了方便说明，没有进行实现。 在这一小节中，尝试解答了 「🤔️ useEffect 的实现原理」和 「🤔️ useEffect 的应用场景」这两个问题。 Class VS Hooks 虽然 Hooks 看起来更酷炫，更简洁。但是在实际开发中我更倾向于使用 Class 来声明组件。两种方法的对比如下： Class Hooks 代码逻辑清晰（构造函数、componentDidMount 等） 需要配合变量名和注释 不容易内存泄漏 容易发生内存泄漏 总的来说，Hooks 对代码编写的要求较高，在没有有效机制保证代码可读性、规避风险的情况下，Class 依然是我的首选。关于内存泄漏，下面是一个例子（目前还没找到方法规避这种向全局传递状态更新函数的做法）： import React, { useState } from \"react\"; import ReactDOM from \"react-dom\"; let func: any; setInterval(() => { typeof func === \"function\" && func(Date.now()); console.log(\"interval\"); }, 1000); function App() { const [num, setNum] = useState 0; if (typeof func !== \"function\") { func = setNum; } return {num}; } function render() { ReactDOM.render(, document.getElementById(\"root\")); } render(); "},"技术笔记/react PureComponent和React.memo的简单作用.html":{"url":"技术笔记/react PureComponent和React.memo的简单作用.html","title":"react PureComponent和React.memo的简单作用","keywords":"","body":"[TOC] react PureComponent和React.memo的简单作用 PureComponent 和 React.memo的作用都是为了性能优化而出现的，目的是减少组件不必要的渲染。区别是PureComponent是作用在class 组件，React.memo是作用在函数组件。 PureComponent 先来看个简单例子： class Child extends React.Component { render() { console.log('Child render function is runing.'); return Child; } } class Parent extends React.Component { state = { num: 1, }; handleClick = () => { this.setState(state => ({ num: state.num + 1, })); }; render() { console.log('Parent render function is runing.'); return ( <> click to change{this.state.num} ); } } 页面很简单，就一个按钮，和只有文本的子组件，父子组件没有任何通信： 当我们点击按钮的时候，会发现父组件和子组件的render函数都被触发了： 但是父子组件之间是没有任何通信的，子组件的渲染函数不应该被执行的，这时候我们可以优化一下代码，把Child组件改成继承React.PureComponent: class Child extends React.PureComponent { render() { console.log('Child render function is runing.'); return Child; } } 这时候我们再次点击按钮，会发现子组件的render函数不会触发了： 然后，当我们把数字作为props传给Child，修改代码为下面： 这时候再次点击按钮，会发现子组件的render函数又会触发了： 这时候，我们可以继续优化Child组件，并再次点击按钮： class Child extends React.PureComponent { shouldComponentUpdate() { return false; } render() { console.log('Child render function is runing.'); return Child; } } 子组件没用到的props改变也不会更新了，当然shouldComponentUpdate还是要按实际需要去写，这里直接返回false，后面render函数都不会再被触发了。 React.memo 我们把上面代码改成函数组件： function Child() { console.log('Child render function is runing.'); return Child; } function Parent() { const [num, setNum] = useState(0); function handleClick() { setNum(num + 1); } console.log('Parent render function is runing.'); return ( <> click to change{num} ); } 这时候点击按钮，父子组件都触发了渲染： 这时候我们只需要修改子组件： function ChildFn() { console.log('Child render function is runing.'); return Child; } const Child = React.memo(ChildFn); 再次点击按钮，子组件不再触发渲染了： 若传了props给子组件，子组件同样会触发渲染。 结语 PureComponent和React.memo都是为了性能优化而出现的，写代码时必须多考虑性能优化 "},"技术笔记/React-redux用法.html":{"url":"技术笔记/React-redux用法.html","title":"React-redux用法","keywords":"","body":"React Redux 用法 class component用法： const mapStateToProps = (state) => ({ todos: state.todos }) const mapDispatchToProps = (dispatch) => { return { // dispatching plain actions increment: () => dispatch({ type: 'INCREMENT' }), decrement: () => dispatch({ type: 'DECREMENT' }), reset: () => dispatch({ type: 'RESET' }), } } class A { ... } export default connect(mapStateToProps, mapDispatchToProps)(A) hook用法： import React from 'react' import { useSelector, useStore } from 'react-redux' export const CounterComponent = () => { const counter = useSelector(state => state.counter) const dispatch = useDispatch() const store = useStore() store.dispatch({type: 'increment-counter'}) return dispatch({ type: 'increment-counter' })}>{counter}{store.getState()} } "},"技术笔记/typescript学习.html":{"url":"技术笔记/typescript学习.html","title":"typescript学习","keywords":"","body":"TypeScript 学习笔记 [TOC] 前言 如今如此广阔的应用领域，对JavaScript 语言的安全性、健壮性和可维护性有更高的要求。尽管ECMAScript标准在近几年有了长足的进步，但在类型检查方面依然无所建树。例如这些场景： 调用别人写的函数，没有任何注释，为了搞清楚类型，只能硬着头皮看函数逻辑 为了保证代码的健壮性，对一个函数的输入参数进行各种假设（类型判断） 维护底层库时，修改参数类型，但是不知道有哪些地方使用 以上情况，归根结底是因为JavaScript是一门动态弱类型语言，对变量的类型非常宽容，而且不会在这些变量和它们的调用者之间建立结构化的契约。如果长期在没有类型约束的环境下开发，就会造成类型思维的缺失，养成不良的编程习惯。 TypeScript就是致力于为JavaScript提供静态类型检查。 1、什么是TypeScript？ 根据官方的定义，它是拥有类型系统的JavaScript的超集，可以编译成纯JavaScript。 TypeScript的特点： TypeScript会在编译代码时，进行严格的静态类型检查 这意味着你可以在编码的阶段发现可能存在的隐患，而不必把它们带到线上去 语言扩展 TS会包括来自ES6和未来提案中的特性，比如异步操作和装饰器，也会从其他语言借鉴某些特性，比如接口和 工具属性 TS可以编译成标准的JavaScript，可以在任何浏览器、操作系统上运行 使用TypeScript 的其他好处 接口定义代替文档 IDE能够提高开发效率，降低维护成本 重塑“类型思维” 2、强类型与弱类型 强类型语言 在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容。 —— Liskov, Zilles 1974 通俗定义 强类型语言不允许改变变量的数据类型，除非进行强制类型转换 弱类型语言 在弱类型语言中，变量可以被赋予不同的数据类型 3、静态类型语言与动态类型语言 通俗定义 静态类型语言：在编译阶段确定所有变量的类型 动态类型语言：在执行阶段确定所有变量的类型 JavaScript与C++对比 静态类型与动态类型对比 4、基本类型 类型注解 作用：相当于强类型语言中的类型声明 语法：(变量/函数):type 枚举类型 一个角色判断的例子 枚举的定义：一组有名字的常量集合 "},"技术笔记/webpack.html":{"url":"技术笔记/webpack.html","title":"webpack","keywords":"","body":"Webpack [TOC] 1. optimization.runtimeChunk runtimeChunk，直观翻译是运行时的chunk文件，作用是把chunks（一些异步组件等需异步加载的js）的映射关系从app.js（总入口）单独提取出来。试想一下不把这部分代码提取出来，每次修改其中一个异步组件，app.js的hash值都会改变，用户都需要重新下载，其实只有chunks的映射关系改变而已。所以runtimeChunk就是用来优化浏览器缓存的，让用户下载最少的代码就能享受到更新。 何为运行时代码？ "},"技术笔记/vue数据绑定问题.html":{"url":"技术笔记/vue数据绑定问题.html","title":"vue数据绑定问题","keywords":"","body":"问题原因： 数据绑定为对象时，对象的属性可新增。由于Vue只会在初始化页面时会使用Object.defineProperty()劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。但是对象新增的属性并没有重写setter、getter方法，导致双向绑定无效。 解决方案： 给所绑定的对象新增属性时，不要直接定义属性，要用Vue.$set方法新增属性。 参考： Vue.$set介绍 剖析Vue原理&实现双向绑定MVVM - 前端足迹 - SegmentFault "},"技术笔记/go语言变量声明后的默认值.html":{"url":"技术笔记/go语言变量声明后的默认值.html","title":"go语言变量声明后的默认值","keywords":"","body":"在 go 语言中，任何类型在声明后没有赋值的情况下，都对应一个零值。 整形如 int8、byte、int16、uint、uintprt 等，默认值为 0。 浮点类型如 float32、float64，默认值为 0。 布尔类型 bool 的默认值为 false。 复数类型如 complex64、complex128，默认值为 0+0i。 字符串 string 的默认值为”“。 错误类型 error 的默认值为 nil。 对于一些复合类型，如指针、切片、字典、通道、接口，默认值为 nil。而数组的默认值要根据其数据类型来确定。例如：var a [4]int，其默认值为[0 0 0 0]。 "},"技术笔记/less 使用技巧.html":{"url":"技术笔记/less 使用技巧.html","title":"less 使用技巧","keywords":"","body":"1.层级关系 让这个box范围内的全部包进来，这样的话就完美的进行调节，再也不用到处找第几行第几个，我刚才在哪个位置给覆盖了。一看便知！ .box{ width: 100%; height: 300px; p{ margin: 10px; span{ padding: 10px; a{ list-style: none; &:nth-child(1){ } } } } } 2.主色调的使用 小米诺基亚等公司，都有自己的主色调。如果每次加一个#e23615太麻烦，而且如果诺基亚要搞活动！过年要换成红色！你完了。。。你做了无数个background和font-color。此时less解决了这个问题 @bg-color: #000; @ft-color: #e1e1e1; .bg-color { background: @bg-color; color: @ft-color; padding: 8px 25px; } 3.拿他当函数用 比如说我在box1中用了很多漂亮的样式，在box2中想使用，但必须把他们的10行样式全复制过来，多次使用很麻烦。怎么办？这次拿他当函数， 第一种：最简单，放进去就行 .x{ background: #000; width: 300px; height: 100px; } .box { .x; border:1px solid #ccc } //相当于这样，而且能多次使用！ //再也不用担心我的学习，步步高打火机，哪里不会点哪里 .box { background: #000; width: 300px; height: 100px; border:1px solid #ccc } 第二种：当函数来回调，自己这个颜色我不确定怎么办，木有关系 @color 就是 function(a) 里面的a，可以瞎起名 @color 可以放默认值懒得动，也可以放全新的颜色。 .x(@color){ background:@color; border:1px solid @color } .x(@color:#ccc){ background:@color; border:1px solid @color } .box { .x(#000); display:flex; } //相当于到一个地方，换一个主题。再也不用担心我的学习 4.一个class有N个方案 比如说这个class叫kings 我给他做出了4种主题，各种大小完全不同。此时我总不能起名叫 kings1，kings2，kings3吧 首先把所有方案排列出来！然后box来显示。 相当于电视机，你放N个台自己选哪个电视剧 @_ 其实是默认的意思，你什么都不加空着就这样 你要加a或b或c就另一种方案 .king(@_, @width:1px, @height:1p, @bg:#fff) { width:@width; height:@height; background:@bg; } .king(a, @width:100px, @height:100p, @bg:#000) { width:@width; height:@height; background:@bg; } .king(b, @width:200px, @height:200p, @bg:#f88) { width:@width; height:@height; background:@bg; } .king(c, @width:300px, @height:300p, @bg:#0000CC;) { width:@width; height:@height; background:@bg; } .box{ .king(a) } 5.简单的计算器 基本的加减乘除在这里可以使用 而且过程中不用担心用不用加px rem 在a里加就行了 @a:100px; .box{ width:(a/2)+3-5*2; } 6.arguments的使用 其实他就是用来 五马分尸的。 比如border的分布:由数字，样式，颜色拼出来。 border: 1px solid #ccc 有没有什么办法用一个就KO掉？那就是arguments .bor(@a:1px, @b:solid, @c:#000) { border:@arguments } .box1{ .bor(); } .box2{ .bor(20px, dashed, #ccc); } "},"其他笔记/面试问题.html":{"url":"其他笔记/面试问题.html","title":"面试问题","keywords":"","body":" 原型链 继承 闭包 闭包是什么 理论角度：闭包是指能够访问到自由变量（自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量）的函数 实践角度：即使创建它的上下文已经销毁，它仍然存在，并引用了自由变量 闭包为什么能访问到局部变量 instanceOf原理 v8垃圾回收机制 new操作符的过程 事件循环机制 promise React setState是异步还是同步 前端模块化规范 commonjs AMD CMD ES module http2.0优化点 二进制分帧:帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。 请求优先级:把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。 多路复用 (Multiplexing) / 连接共享:在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。 头部压缩:http1.x的头带有大量信息，而且每次都要重复发送。http/2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送: 遇到问题如何解决 "},"其他笔记/前端开发面试常见问题.html":{"url":"其他笔记/前端开发面试常见问题.html","title":"前端开发面试常见问题","keywords":"","body":"三栏布局的五种方法： float absolute flex Table-cell Grid页面布局的变通： 三栏布局：左右宽度固定，中间自适应 三栏布局：上下宽度固定，中间自适应 两栏布局：左宽度固定，右自适应 两栏布局：右宽度固定，左自适应 两栏布局：上宽度固定，下自适应 两栏布局：下宽度固定，上自适应 js获取盒模型的宽高： dom.style.width/height 只能获取内联样式的宽高，外联样式取不到 Dom.currentStyle.width/height 只支持ie Window.getComputedStyle.width/height 支持ie、ff、chrome dom.getBoundingClientRect().width/height 通过视窗位置的方法获取 如何创建BFC： 1、float的值不是none。 2、position的值不是static或者relative。 3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex 4、overflow的值不是visible get和post的区别 Get请求的回退是无害的，而post请求会重新提交请求 Get请求的url地址可以被收藏，post不可以 Get请求会被浏览器主动缓存，post不会 Get请求会保存在浏览器历史记录里，post不会 Get请求在url中传递的参数是有长度限制的，post没有 Get请求比post不安全，因为参数直接暴露在url上，所以不能用来传递敏感信息 Get请求的参数放在url上，而post放在request body上http状态码： 1xx：指示信息，表示请求已接收，继续处理 2xx：成功，表示请求已被成功接收 3xx：重定向，要完成请求必须进行更进一步的操作 4xx：客户端错误，请求有语法错误或请求无法实现 5xx：服务器错误，服务器未能实现合法的请求 "}}