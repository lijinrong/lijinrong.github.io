# 前端性能优化手段

[TOC]

## 一、缓存

欢迎来到「前端性能优化之旅」的第一站 —— 缓存。

当浏览器想要获取远程的数据时，我们的性能之旅就开始了。然而，我们并不会立即动身（发送请求）。在计算机领域，很多性能问题都会通过增加缓存来解决，前端也不例外。和许多后端服务一样，前端缓存也是多级的。下面让我们一起来具体看一看。

### 1. 本地数据存储

通过结合本地存储，可以在业务代码侧实现缓存。

对于一些请求，我们可以直接在业务代码侧进行缓存处理。缓存方式包括 `localStorage`、`sessionStorage`、`indexedDB`。把这块加入缓存的讨论也许会有争议，但利用好它确实能在程序侧达到一些类似缓存的能力。

例如，我们的页面上有一个日更新的榜单，我们可以做一个当日缓存：

```javascript
// 当用户加载站点中的榜单组件时，可以通过该方法获取榜单数据
async function readListData() {
    const info = JSON.parse(localStorage.getItem('listInfo'));
    if (isExpired(info.time, +(new Date))) {
        const list = await fetchList();
        localStorage.setItem('listInfo', JSON.stringify({
            time: +(new Date),
            list: list
        }));
        return list;
    }
    return info.list;
}
```

`localStorage` 大家都比较了解了，`indexedDB` 可能会了解的更少一些。想快速了解 `indexedDB` 使用方式可以看[这篇文章](https://medium.com/free-code-camp/a-quick-but-complete-guide-to-indexeddb-25f030425501)[1]。

从前端视角看，这是一种本地存储；但如果从整个系统的维度来看，很多时候其实也是缓存链条中的一环。对于一些特殊的、轻量级的业务数据，可以考虑使用本地存储作为缓存。

### 2. 内存缓存（Memory）

当你访问一个页面及其子资源时，有时候会出现一个资源被使用多次，例如图标。由于该资源已经存储在内存中，再去请求反而多此一举，浏览器内存则是最近、最快的响应场所。

缓存并无明确的标准规定，它与 HTTP 语义下的缓存关联性不大，算是浏览器帮我们实现的优化，很多时候其实我们意识不到。

对内存缓存感兴趣，可以在[这篇文章](https://calendar.perfplanet.com/2016/a-tale-of-four-caches/)[2]的 Memory Cache 部分进一步了解。

### 3. Cache API

当我们没有命中内存缓存时，是否就开始发送请求了呢？其实不一定。

在这时我们还可能会碰到 Cache API 里的缓存，提到它就不得不提一下 Service Worker 了。它们通常都是配合使用的。

首先明确一下，这层的缓存没有规定说该缓存什么、什么情况下需要缓存，它只是提供给了客户端构建请求缓存机制的能力。如果你对 PWA 或者 Service Worker 很了解，应该非常清楚是怎么一回事。如果不了解也没有关系，我们可以简单看一下：

首先，Service Worker 是一个后台运行的独立线程，可以在代码中启用

```javascript
// index.js
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(function () {
        // 注册成功
    });
}
```

之后需要处理一些 Service Worker 的生命周期事件，而其中与这里提到的缓存功能直接相关的则是请求拦截：

```javascript
// sw.js
self.addEventListener('fetch', function (e) {
    // 如果有cache则直接返回，否则通过fetch请求
    e.respondWith(
        caches.match(e.request).then(function (cache) {
            return cache || fetch(e.request);
        }).catch(function (err) {
            console.log(err);
            return fetch(e.request);
        })
    );
});
```

以上代码会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。与内存缓存不同，Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。

Service Worker 与 Cache API 其实是一个功能非常强大的组合，能够实现堆业务的透明，在[兼容性](https://caniuse.com/#feat=serviceworkers&search=service worker)上也可以做成渐进支持。还是非常推荐在业务中尝试的。当然上面代码简略了很多，想要进一步了解 Service Worker 和 Cache API 的使用可以看[这篇文章](https://juejin.im/post/5aca14b6f265da237c692e6f)[3]。同时推荐使用 Google 的 [Workbox](https://developers.google.com/web/tools/workbox/)。

### 4. HTTP 缓存

如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了。这个时候出现的就是我们所熟知的 HTTP 缓存规范。

HTTP 有一系列的规范来规定哪些情况下需要缓存请求信息、缓存多久，而哪些情况下不能进行信息的缓存。我们可以通过相关的 HTTP 请求头来实现缓存。

HTTP 缓存大致可以分为强缓存与协商缓存。

#### 4.1. 强缓存

在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。

与其相关的响应头则是 `Expires` 和 `Cache-Control`。在 `Expires` 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 `Cache-Control` 则可以通过给它设置一个 `max-age`，来控制过期时间。例如，`max-age=300` 就是表示在响应成功后 300 秒内，资源请求会走强缓存。

#### 4.2. 协商缓存

你可能也感觉到了，强缓存不是那么灵活。如果我在 300 秒内更新了资源，需要怎么通知客户端呢？常用的方式就是通过协商缓存。

我们知道，远程请求慢的一大原因就是报文体积较大。协商缓存就是希望能通过先“问一问”服务器资源到底有没有过期，来避免无谓的资源下载。这伴随的往往会是 HTTP 请求中的 304 响应码。下面简单介绍一下实现协商缓存的两种方式：

一种协防缓存的方式是：服务器第一次响应时返回 `Last-Modified`，而浏览器在后续请求时带上其值作为 `If-Modified-Since`，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。

上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— `ETag`。服务器第一次响应时返回 `ETag`，而浏览器在后续请求时带上其值作为 `If-None-Match`。一般会用文件的 MD5 作为 `ETag`。

作为前端工程师，一定要善于应用 HTTP 缓存。如果想要了解更多关于 HTTP 缓存的内容，可以阅读[这篇文章](https://github.com/amandakelake/blog/issues/41)[4]。

> 上面这些的各级缓存的匹配机制里，都是包含资源的 uri 的匹配，即 uri 更改后不会命中缓存。也正是如此，我们目前在前端实践中都会把文件 HASH 加入到文件名中，避免同名文件命中缓存的旧资源。

### 5. Push Cache

假如很不幸，以上这些缓存你都没有命中，那么你将会碰到最后一个缓存检查 —— Push Cache。

Push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源。例如，你在请求 www.sample.com 时，服务端不仅发送了页面文档，还一起推送了 关键 CSS 样式表。这也就避免了浏览器收到响应、解析到相应位置时才会请求所带来的延后。

不过 HTTP/2 Push Cache 是一个比较底层的网络特性，与其他的缓存有很多不同，例如：

- 当匹配上时，并不会在额外检查资源是否过期；
- 存活时间很短，甚至短过内存缓存（例如有文章提到，Chrome 中为 5min 左右）；
- 只会被使用一次；
- HTTP/2 连接断开将导致缓存直接失效；
- ……

如果对 HTTP/2 Push 感兴趣，可以看看[这篇文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)[5]。

------

好了，到目前为止，我们可能还没有发出一个真正的请求。这也意味着，在缓存检查阶段我们就会有很多机会将后续的性能问题扼杀在摇篮之中 —— 如果远程请求都不必发出，又何须优化加载性能呢？

所以，审视一下我们的应用、业务，看看哪些性能问题是可以在源头上解决的。

不过很多时候，能通过缓存解决的问题只有一部分。所以下面我们会继续这趟旅行，目前我们已经有了一个好的开始，不是么？



## 二、发送请求

在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。

> 在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。

介绍网络请求其实可以包含复杂的网络知识。不过，今天咱们的旅程主要聚焦于“前端性能优化”。因此，主要会介绍一些在这个环节中，前端性能优化可能会做的事儿。

### 1. 避免多余重定向

重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。

重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。

同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。

### 2. DNS 预解析

基本我们访问远程服务的时候，不会直接使用服务的出口 IP，而是使用域名。所以请求的一个重要环节就是域名解析。

DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：

1. 先检查本地 hosts 文件中是否有映射，有则使用；
2. 查找本地 DNS 缓存，有则返回；
3. 根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；
4. 如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；
5. 根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；
6. 当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。

更详细的介绍可以看[这篇文章](https://www.zhihu.com/question/23042131)[1]。

这里我们需要了解的是：

- 首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；
- 其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。

[DNS Prefetch](https://www.w3.org/TR/resource-hints/#dns-prefetch)[2] 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：

```html
<link rel="dns-prefetch" href="//yourwebsite.com">
```

1当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了👇

> user agent SHOULD resolve as early as possible

### 3. 预先建立连接

我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 [Preconnect](https://www.w3.org/TR/resource-hints/#preconnect)[3] 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”

根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：

- 首先，解析 Preconnect 的 url；
- 其次，根据当前 link 元素中的属性进行 cors 的设置；
- 然后，默认先将 credential 设为 `true`，如果 cors 为 `Anonymous` 并且存在跨域，则将 credential 置为 `false`；
- 最后，进行连接。

使用 Preconnect 只需要将 `rel` 属性设为 `preconnect` 即可：

```html
<link rel="preconnect" href="//sample.com">
```

当然，你也可以设置 CORS：

```html
<link rel="preconnect" href="//sample.com" crossorigin>
```

需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。

### 4. 使用 CDN

当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。

对于静态资源，我们可以考虑通过 CDN 来降低时延。

对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。

想了解更多 CDN 的工作方式可以阅读[这篇文章](https://yq.aliyun.com/articles/577708)[4]。

------

下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。

![resource timing line](../assets/A88711DA-9014-4DD5-B056-9FB87B34D3C5.png)

在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。

过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。

## 三、服务端响应

把这一部分放进前端性能优化并不是很严谨：

- 其一，服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域；
- 其二，我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。

所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。

### 1. 使用流进行响应

目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。

例如 [css-only-chat-node](https://github.com/alienzhou/css-only-chat-node) 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。

### 2. 业务聚合

BFF 非常合适做的一件事就是后端服务的聚合。

如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。

此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。

### 3. 避免代码问题

代码问题其实就非常细节了。简单列举一些常见的问题：

- `async` `await` 的不当使用导致并行请求被串行化了；
- 频繁地 `JSON.parse` 和 `JSON.stringify` 大对象；
- 正则表达式的灾难性回溯；
- 闭包导致的内存泄漏；
- CPU 密集型任务导致事件循环 delay 严重；
- 未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；
- ……

------

「前端性能优化之旅」在这一阶段只能蜻蜓点水了。NodeJS 作为 BFF 还是比较常见的，所以在旅途中也提了一下。下面我们就要重新回到前端领域了，准备好了么？

## 四、页面解析与处理

在上一站中，我们简单介绍了服务端处理与响应，到目前为止我们已经经历了很多环节，也已经有了许多「性能优化的武器」。像是

- 利用各级缓存进行优化
- 提前进行 DNS 查询或建立连接等方式加速请求
- 在服务端避免不必要的耗时
- ……

不过，不要掉以轻心，后续仍然有大量的工作等待我们来优化。下面就到了客户端接收响应的阶段了。

### 主要工作

这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：

- 页面 DOM 的解析；
- 页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；
- 静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；

大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。

### 1. 注意资源在页面文档中的位置

我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。

JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。

仅仅看 DOM 与 CSS 的关系，则如下图所示：

![pipeline for dom and css](https://alienzhou.com/projects/fe-performance-journey/assets/img/pipeline1.d4d1593d.png)

HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：

![pipeline for dom and css with js](https://alienzhou.com/projects/fe-performance-journey/assets/img/pipeline2.de807446.png)

根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 ——

> JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。

所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 `<head>` 之中（即页面的头部），把 JavaScript 脚本放在 `<body>` 的最后（即页面的尾部）。

关于这部分的一些解释可以看[这篇文章](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)[1]。

### 2. 使用 defer 和 async

上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。

那除了将脚本放在 `body` 的最后，还有什么优化方法么？是有的。

可以使用 `defer` 或 `async` 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：

![async defer](https://alienzhou.com/projects/fe-performance-journey/assets/img/async-defer.b9a4dc94.jpeg)

`defer` 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 `async` 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。

根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 `async` 可以有效避免这些非核心功能的加载影响页面解析速度。

### 3. 页面文档压缩

HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。

------

说一句题外话，你知道与页面解析密切相关的 DOMContentLoaded 事件何时么？interactive/complete 等 readyState 具体代表什么么？如果不太了解可以从[HTML spec](https://html.spec.whatwg.org/multipage/dom.html#current-document-readiness)[2]里看。

用原话来说就是：

> Returns "loading" while the Document is loading, "interactive" once it is finished parsing but still loading subresources, and "complete" once it has loaded.

> The readystatechange event fires on the Document object when this value changes.

> The DOMContentLoaded event fires after the transition to "interactive" but before the transition to "complete", at the point where all subresources apart from async script elements have loaded.

------

好了，在这一站我们又了解了页面的解析过程及其性能优化。

正如开头所说，其实解析页面、加载资源、使用资源是三个紧密相关的过程。在这里我们主要着眼于页面的解析，而在「前端性能优化之旅」的下一站，我们则会一起来涉足到这部分的其他诸多优化点中。

## 五、页面静态资源

在旅程的上一站中，我们介绍了基本的页面解析机制，通过对资源加载顺序和脚本加载的控制，避免了无谓的阻塞，优化了解析性能。

也正如上一站中所说，这时浏览器除了解析页面 DOM 外，还会对页面包含的静态资源发起请求，请求回来后会执行或使用资源。这一站咱们就来具体看看这个阶段。

首先还是从宏观上来了解一下：

### 1. 总体原则

这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。

但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于：

- 减少不必要的请求
- 减少包体大小
- 降低应用资源时的消耗
- 利用缓存

为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。

#### 1.1. 减少不必要的请求

核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。

同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。

减少不必要的请求主要分为几个维度：

- 对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；
- 对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；
- 对于可以合并的资源，进行资源合并也是一种方法。

#### 1.2. 减少包体大小

包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。

减少包体大小常用的方式包括了：

- 使用适合当前资源的压缩技术；
- 避免再响应包体里“塞入”一些不需要的内容

#### 1.3. 降低应用资源时的消耗

以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。

此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。

#### 1.4. 利用缓存

还记得咱们这趟旅程从哪出发的么？没错，缓存。

在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。

由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。

### 2. 针对各类资源的性能优化 🚀

以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。

> 如果你一口气读到这里，可能有些累了。不如先伸个懒腰放松下，整理回忆一下之前的内容。

如果准备好了，咱们就继续出发吧👇

- [JavaScript 优化](https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html)
- [CSS 优化](https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html)
- [图片优化](https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html)
- [字体优化](https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html)
- [视频优化](https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html)

![break](https://alienzhou.com/projects/fe-performance-journey/assets/img/break.77195f46.jpg)

------

### 本节告一段落

好了，如果你已经阅读完了上面各类资源的具体优化措施，那么恭喜，你已经在「前端性能优化之旅」上行过大半。下面我们会收拾行装继续回到主路上。

下一站我们会来到“运行时”（runtime），看看有哪些性能优化的注意点与技术手段。

## 六、运行时

虽然我们已经趟过了资源加载这个优化的大头，但仍然不能掉以轻心，在应用运行时你仍然可能踩到一些性能的“坑”。下面就让我们来具体看一看。

### 1. 注意强制同步布局

#### 1.1. 什么是强制同步布局

作为前端，大家应该对“强制同步布局”并不陌生。如果你不太了解，这里简单介绍一下。首先你需要知道的是，显示器有一个自己的刷新频率，例如每秒 60 次（60 FPS）。这就意味着，每过 16.6ms，浏览器就会将截止上次刷新后的元素变动应用到屏幕上。这里就不得不提到渲染管线了。

![pipeline](https://alienzhou.com/projects/fe-performance-journey/assets/img/pipeline.dc48e4bd.jpg)

在渲染管线中，有一步叫做 Layout，也就是布局。它会计算元素的大小、位置信息，而且一处的改动几乎会影响到整个文档页面。所以 Layout 的消耗是非常巨大的。而我们所说的 reflow（firefox）与 layout（Chrome/Opera/Safari/IE），都是指的这一过程。另一方面，渲染线程和 JavaScript 执行线程是互斥的，所以这 16.6ms 还会被 JavaScript 的执行所瓜分，可见时间并不那么“富裕”。

我们先来看一段代码：

```javascript
var $ele = document.getElementById('main');
var height = $ele.offsetHeight;
// ……
```

上述代码获取了元素的 `offsetHeight` 值，浏览器此时会使用上一次渲染后的缓存值进行返回，所以浏览器消耗并不大。

而有一些 JavaScript 操作会导致浏览器需要提前执行布局操作，这种操作就被称为“强制同步布局”。我们把上面的代码改成如下所示：

```javascript
var $ele = document.getElementById('main');
$ele.classList.remove('large');
var height = $ele.offsetHeight;
// ……
```

由于我们在修改元素的 className 后又立刻获取了它的高度，为了保证高度值正确，浏览器会立即进行布局，然而我们的本意可能并非如此 —— 也许 `large` 并不会影响高度，也许我们只是想获取上一帧的结果…… 针对这种目的，下面的写法会更合适，同时可以避免强制同步布局。

```javascript
var height = $ele.offsetHeight;
var $ele = document.getElementById('main');
$ele.classList.remove('large');
// ……
```

从这个例子可以看到，我们很可能一不小心就触发了强制同步布局。除了上例中的 `offsetHeight`，还有许多会[触发强制同步布局](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)[1]的属性。而 [CSS Triggers](https://csstriggers.com/)[2] 这个网站在 Layout 之外，列出了各个浏览器中会触发 Paint 和 Composite 的 CSS 属性。

#### 1.2. 尝试使用 RAF 避免强制同步布局

在强制同步布局的问题上，还有一些更严重的列子，例如在循环中不断触发强制同步布局。

如果你希望避免在浏览器进行页面重绘后执行一些操作，你可以使用 [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) API。由于上一帧的旧布局值是可以直接获取的，所以我们可以将布局查询的操作放在 `requestAnimationFrame` 中。

```javascript
window.requestAnimationFrame(() => {
    var $ele = document.getElementById('main');
    var height = $ele.offsetHeight;
    // ……
});
```

但是请注意，如果像下面这样犯了和之前一样的错误，在查询布局之前设置了新的元素样式/布局属性，那使用了 `requestAnimationFrame` 也无法避免性能问题。

```javascript
window.requestAnimationFrame(function () {
    var $ele = document.getElementById('main');
    $ele.classList.remove('large');
    var height = $ele.offsetHeight;
    // ……
});
```

#### 1.3. 批量化你的操作

批量化是计算机程序优化中的重要手段之一。例如一些数据库在写操作上最终也是会将其批量化后再统一进行磁盘 I/O。所以对于元素布局的查询操作，我们也可以尝试使用这种手段。我们可以将这些操作批量化存储下来，等到下一次 `requestAnimationFrame` 触发时一起执行。[FastDom](https://github.com/wilsonpage/fastdom) 就是一个帮你封装了这类操作的开源库

> By batching DOM access we avoid unnecessary document reflows and dramatically speed up layout performance. Each measure/mutate job is added to a corresponding measure/mutate queue. The queues are emptied (reads, then writes) at the turn of the next frame using window.requestAnimationFrame.

上面是它的基本工作原理，和我们提到的思路是一样的。基本的使用方法如下：

```javascript
fastdom.measure(() => {
    const width = element.clientWidth;
});
```

```javascript
fastdom.mutate(() => {
    element.style.width = width + 'px';
});
```

### 2. 长列表优化

有些时候，你可能会需要在页面上展示一个包含上百个元素的列表（例如一个 Feed 流）。每个列表元素还有着复杂的内部结构，这显然提高了页面渲染的成本。甚至当你使用一些像 React 这样的库时，长列表的问题会被进一步放大。那么，有没有什么方法来优化长列表呢？

#### 2.1. 实现 Virtual List

Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能。它的核心思想在于：只渲染可见区域附近的列表元素。下图左边就是 Virtual List 的效果，可以看到只有视口内和临近视口的上下区域内的元素会被渲染。

![virtual list](data:image/png;base64,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)

不过这样带来的一个问题就是，由于只渲染固定 N 个元素，所以在页面滚动后，它们仍然留在原位。对于这个问题可以使用 `position: absolute` 配合 `transform: translate3d()` 来解决，手动设置展示元素的偏移量。

其大致的实现思路如下：

1. 监听页面滚动（或者其他导致视口变化的事件）；
2. 滚动时根据滚动的距离计算需要展示的列表项；
3. 将列表项中展示的数据与组件替换成当前需要展示的内容；
4. 修改偏移量到对应的位置。

这样还有一个好处，相当于是不断改变这 N 个元素的位置属性和内部的一些节点，不会有频繁的 DOM 创建与销毁，配合下面提到的 composite 可以获得不错的性能。

如果你想要使用这项技术，除了自己实现外，一些常见的框架也有不错的开源实现。例如：

- 基于 React 的 [react-virtualized](https://github.com/bvaughn/react-virtualized)，它的开发者也在 [dev.to 上分享了一些关于 virtual list 的内容](https://dev.to/nishanbajracharya/what-i-learned-from-building-my-own-virtualized-list-library-for-react-45ik)[3]；
- 基于 Vue 的 [vue-virtual-scroll-list](https://github.com/tangbc/vue-virtual-scroll-list)；
- 基于 Angular 的 [ngx-virtual-scroller](https://github.com/rintoj/ngx-virtual-scroller)；
- ……

####  2.2. 原生的 Virtual Scroller

Virtual List 在 feed 流、图片库等很多场景下非常有用，开源组件的下载量也说明了业务对这个功能的需求量。那么自然会想到，如果由浏览器层面来提供类似的能力，显然适用性会更强，性能可能也会更好。Virtual Scroller 就是上述逻辑的浏览器原生实现。[Chrome Dev Summit 2018](https://youtu.be/UtD41bn6kJ0?t=1186)[4] 上演示了它的效果。使用上也很简单：

```html
<script type="module">
    import "std:virtual-scroller";
</script>

<virtual-scroller>
    <div>item 1</div>
    <div>item 2</div>
    <div>item 3</div>
    <div>item 4</div>
    ……
    <div>item 1000</div>
</virtual-scroller>
```

注意，`<virtual-scroller>` 是内置（built-in）模块提供的，所以需要从 `std` 中导入。目前（2019.08）还不建议在生产环境中使用该功能。如果想得到类似的效果还是建议使用基于 JavaScript 实现的库。当然，非常期待未来在生产环境中可以用上这个功能。

想了解更多关于 Virtual Scroller 的信息可以[看这里](https://github.com/WICG/virtual-scroller)[5]。

### 3. 避免 JavaScript 运行时间过长

上面我们提到了，屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。下面我们来看下如何避免 JavaScript 长时间执行而导致的掉帧。

#### 3.1. 任务分解

你可以在 Chrome 控制台执行如下命令：

```javascript
document.body.innerHTML = '';
for(var i = 0; i < 100; i++) {1+1}
```

可以看到页面被立即清空了。然后我们修改一下迭代的次数，从 100 次增加到 10 亿次：

```javascript
document.body.innerHTML = '';
for(var i = 0; i < 1e9; i++) {1+1}
```

这时候运行你会发现页面没有变化，控制台也卡住了。过了几秒后页面被清空了。这是因为 JavaScript 的长时间执行阻塞了渲染线程。

既然长时间的运行会导致渲染阻塞，那么最简单的方法就是把我们的任务拆成一个个持续时间更短的小任务，分散到各个帧中执行，例如改造成下面这样：

```javascript
document.body.innerHTML = '';

let step = 0;
function subtask() {
    if (step === 1e9) {
        return;
    }
    window.requestAnimationFrame(function () {
        for(var i = 0; i < 1e8; i++) {step++; 1+1}
        subtask();
    });
}
subtask();
```

我们把 10 亿次分散为十个 1 亿次的子任务，虽然同样执行了 10 亿次计算，但是页面迅速被清空了。

此外，浏览器还有一个更强大的 API 来帮助你更精细地进行计算调度，它就是 [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback)。它会在浏览器“空闲”的时候执行注册的回调函数，避免在主线程“拥挤”的时候执行某些代码。它支持你设定一个超时参数，保证在超时后，即使仍然没有空闲时间也必须执行回调。回调函数会接收一个 [`IdleDeadline`](https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline) 类型的参数，你可以通过 `.didTimeout` 来查看是否是超时执行，还可以通过执行 `.timeRemaining()` 方法来查看剩余的空闲时间。

```javascript
window.requestIdleCallback(deadline => {
    if (deadline.timeRemaining() > 100) {
        // 一些可以等浏览器空闲了再去做的事
        // ……
    }
}, {timeout: 5000})
```

上面是基本的使用方式，具体的使用方式可以[查看这里](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)[6]

#### 3.2. 延迟执行

一般来说，延迟执行分为两种策略：

- 一种是懒执行，例如当我需要某个值时，我才去计算；
- 第二种是延后执行，即利用 `setTimeout`、`requestIdleCallback` 这样的方法把计算放到后续的事件循环或空闲时刻。

一些场景下，这两个都是可行的方法。除此以外，在 [Idle Until Urgent](https://philipwalton.com/articles/idle-until-urgent/)[7] 中作者介绍了一种改进的方法：把计算放到 `requestIdleCallback` 中，如果你一直不需要用到计算结果也没有关系，它会等到空闲时再执行，不影响性能；而当你要使用时，如果还未计算好则会立刻进行计算并返回结果，同时取消未执行的 `requestIdleCallback`。

> 我们在这两部分都提及了 `requestIdleCallback`，它确实是个非常不错的 API，然而目前（2019.08）[兼容性不是很乐观](https://caniuse.com/#feat=requestidlecallback)。如果你希望在生产环境中使用，建议使用 [polyfill](https://github.com/aFarkas/requestIdleCallback)。

#### 3.3. 并行计算

对于一些 CPU 密集型的计算场景，除了在主 JavaScript 线程中拆分调度任务、异步执行之外，我们还可以考虑将计算与主线程并行。在浏览器中启用并行线程可以使用 [Web Worker](https://www.html5rocks.com/en/tutorials/workers/basics/)[8] 中。在 Web Worker 标准出现之前，你能做的只是将任务异步化（asynchronously），而有了 Web Worker，你就可以并行（concurrency）地执行 JavaScript 了。

下面提供了 Web Worker 的基本使用方式：

```javascript
// index.js
const worker = new Worker('worker.js');

worker.addEventListener('message', function (e) {
    console.log(`result is ${e.data}`);
}, false);

worker.postMessage('start');
```

```javascript
// worker.js
self.addEventListener('message', function (e) {
    if (e.data === 'start') {
        // 一些密集的计算……
        self.postMessage(result);
    }
}, false);
```

### 4. 善用 Composite

Composite 这个概念和我们的渲染管线关系密切，可以看到它处于最后一步。

![pipeline](https://alienzhou.com/projects/fe-performance-journey/assets/img/pipeline.dc48e4bd.jpg)

由于之前我们说到，元素布局可能会影响到整个页面，那么自然我们就会想，是否能尽可能减少影响的范围呢？在某些情况下是可以的。例如下面这两个元素：

```css
.main {
    height: 200px;
    width: 200px;
    background: black;
}

.fixed {
    position: fixed;
    top: 20px;
    left: 20px;
    transform: translateZ(0);
    width: 100px;
    height: 100px;
    background: red;
}
```

```html
<div class="main"></div>
<div class="fixed"></div>
```

浏览器会将其处理为两个渲染层，其中 `.fixed` 元素由于设置了 3D transform，所以会从普通的渲染层提升至合成层，拥有独立的 GraphicsLayers。当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。下图展示了当前的两个合成层：

![layer](https://alienzhou.com/projects/fe-performance-journey/assets/img/layer.bd509f7c.png)

总得来说，合成层在性能优化上的优点在于：

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快；
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint。

但同时，也要注意避免层爆炸，防止在无法进行层压缩的情况下出现过多的层，反而导致性能的下降。这篇文章介绍了 [composite 的原理及其相关应用](https://fed.taobao.org/blog/2016/04/26/performance-composite/)[9]。

### 5. 滚动事件的性能优化

前端最容易碰到的性能问题的场景之一就是监听滚动事件并进行相应的操作。由于滚动事件发生非常频繁（相较于用户点击、hover 等事件），所以频繁地执行监听回调就容易造成 JavaScript 执行与页面渲染之间互相阻塞的情况。

滚动的性能优化其实也是一种综合性的优化。它主要是会将上述的各类性能问题放大了，所以在优化措施中，你仍然需要避免出现上面提到的长时间的 JavaScript 执行、强制同步布局等问题。

此外，基于滚动这个特殊场景，这里再介绍两个处理滚动性能时非常常见的技术：防抖和节流。

当一个事件频繁触发，而你希望间隔一定的时间再触发相应的函数时就会使用节流（throttle）。例如在页面滚动时，每 200ms 进行一次页面背景颜色的修改。

当一个事件频繁触发，而你希望在事件触发结束一段时间后（此段时间内不再有触发）才实际触发响应函数时会使用防抖（debounce）。例如用户一直点击按钮，但你不希望频繁发送请求，你就可以设置当点击后 200ms 内用户不再点击时才发送请求。

这两个技术也是前端非常常用的技术，例如 lodash 中就有 [throttle](https://lodash.com/docs/4.17.15#throttle) 和 [debounce](https://lodash.com/docs/4.17.15#debounce) 的对应实现。如果你对它们不太了解，可以看下面这两篇文章：

- [函数节流的实现 (throttle)](https://github.com/lessfish/underscore-analysis/issues/22)[10]
- [函数去抖的实现 (debounce)](https://github.com/lessfish/underscore-analysis/issues/21)[11]

### 6. Passive event listeners

在介绍 Passive event listeners 是如何让滚动更顺畅之前，我们先来看下为什么会有 Passive event listeners。

考虑下面这段代码：

```javascript
document.addEventListener('touchstart', function (e) {
    // 做了一些操作……
    e.preventDefault();
}, true);
```

我们知道，在 `touchstart` 中调用了 `e.preventDefault()` 会阻止页面的滚动与缩放。那么浏览器是如何知道不要让页面滚动与缩放的呢？当然是因为我们调用了 `e.preventDefault()`，你可能认为这是废话，不过问题就在这。如果浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件。所以不管你是否调用了 `e.preventDefault()`，当你添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费事件执行完你的回调，然后根据结果来判断是否需要滚动页面。如果的操作花费了 200ms，那页面只能在 200ms 后再滚动或缩放，这就导致了性能问题。

那你肯定会想，很多时候我不会阻止默认事件呀，我有没有办法告诉浏览器，让它不用等啦（默认行为没有被禁用），直接滚动页面就行呢？[Passive event listeners 就是为此而生的](https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md)[12]。使用方式很简单：

```javascript
document.addEventListener('touchstart', function (e) {
    // 做了一些操作……
}, {passive: true});
```

只需要在第三个参数中传入 `{passive: true}` 即可。

然而和其他新特性一样，对于 Passive event listeners 我们也需要考虑[兼容性](https://caniuse.com/#feat=passive-event-listener)。由于在低版本浏览器中，第三个参数是用来设置是否进行事件捕获的。所以使用时建议进行特性检测：

```javascript
// 这段特性检测的方法很巧妙
let supportsPassive = false;
try {
    const opts = Object.defineProperty({}, 'passive', {
        get: function() {
            supportsPassive = true;
        }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
} catch (e) {}


document.addEventListener('touchstart', function (e) {
    // 做了一些操作……
}, supportsPassive ? {passive: true} : false);
```

[这个视频展示了 Passive event listeners 带来的性能与体验提升](https://www.youtube.com/watch?v=NPM6172J22g)，视频中右侧画面是使用了 Passive event listeners 的效果。

------

运行时性能是前端性能优化中非常重要的一块。这篇文章里列举了常见场景下的通用优化手段。才外，目前大多数应用都是构建在 React/Vue/Angular 之上（当然也有 jQuery），针对具体框架的性能优化又会是好几个新的话题，后续如果有机会也希望能将它们补充进来。

不过，不管什么框架在前端最终都会运行在浏览器上、使用 JavaScript 引擎（至少目前是），所以这些针对以这些通用性的性能优化思路作为基础，可以帮你更好理解与处理遇到的性能问题。

## 七、预加载

在之前的旅途中，我们提到了很多关于资源加载的优化，包括怎么加快连接的建立、怎么减少包体大小、怎么减少请求数等。但还有一种变相加快加载速度的技术 —— 预加载。

预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。

在「性能优化之旅」的最后一站，我会给你介绍一些预加载技术，包括使用览器提供的能力，或者巧用 JavaScript 中的相关 API。此外，除了预加载技术，预加载的一大核心问题还在于预加载策略，即如何判断资源是否需要预加载以及合适加载，以保证最高的效率。

### 1. 预加载技术

#### 1.1. Resource Hints

[Resource Hints](https://www.w3.org/TR/resource-hints/)[1] 是一种预加载相关的标准，它告诉浏览器哪些源下的资源我们的 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender。此外，还有一个与 Resource Hints 类似的 Preload 我们也会在这里介绍一下。

在发起请求部分我们已经介绍了[如何使用 DNS Prefetch 来预解析 DNS](https://alienzhou.com/projects/fe-performance-journey/2-request/#2-dns-解析)、[如何使用 Preconnect 来预先建立连接](https://alienzhou.com/projects/fe-performance-journey/2-request/#3-预先建立连接)。所以下面会其他三块：Prefetch、Prerender、Preload。

##### 1.1.1. Prefetch

你可以把 Prefetch 理解为资源预获取。一般来说，可以用 Prefetch 来指定在紧接着之后的操作或浏览中需要使用到的资源，让浏览器提前获取。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，并且像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。其中 `as` 属性用于指定资源的类型，与 Preload 规范一致，[基本涵盖了所有资源类型](https://www.w3.org/TR/preload/#as-attribute)[2]。

```html
<link rel="prefetch" href="/prefetch.js" as="script">
```

##### 1.1.2. Prerender

Prerender 比 Prefetch 更进一步，可以粗略地理解不仅会预获取，还会预执行。

> The prerender link relation type is used to identify a resource that might be required by the next navigation, and that the user agent SHOULD fetch and execute.

如果你指定 Prerender 一个页面，那么它依赖的其他资源，像 `<script>`、`<link>` 等页面所需资源也可能会被下载与处理。但是预处理会基于当前机器、网络情况的不同而被不同程度地推迟。例如，会根据 CPU、GPU 和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。

```html
<link rel="prerender" href="//sample.com/nextpage.html">
```

##### 1.1.3. Preload

在遇到需要 Preload 的资源时，浏览器会 **立刻** 进行预获取，并将结果放在内存中，资源的获取不会影响页面 parse 与 load 事件的触发。直到再次遇到该资源的使用标签时，才会执行。由于我们会将 `<script>` 标签置于 `<body>` 底部来保证性能，因此可以考虑在 `<head>` 标签中适当添加这些资源的 Preload 来加速页面的加载与渲染。

```html
<link rel="preload" href="./nextpage.js" as="script">
```

到这里大家肯定会好奇，Preload 与 Prefetch 有什么区别呢？它们非常容易混淆，在标准里有这么一段话解释两者区别：

> The application can use the preload keyword to initiate early, high-priority, and non-render-blocking fetch of a CSS resource that can then be applied by the application at appropriate time.

与 Prefetch 相比，Preload 会[强制浏览器立即获取资源，并且该请求具有较高的优先级](https://www.w3.org/TR/preload/#x2.link-type-preload)（mandatory and high-priority），因此建议对一些当前页面会马上用到资源使用 Preload；相对的，Prefetch 的资源获取则是可选与较低优先级的，其是否获取完全取决于浏览器的决定，适用于预获取将来可能会用到的资源。

> 如果对 Resource Hints 感兴趣，可以在我之前的文章中[进一步了解它们](https://juejin.im/post/5b4b66f0f265da0f9155feb6)[3]。

##### 1.1.4. webpack 中的使用方式

预加载可以配合 code split 来使用，可以在降低初始加载量的情况下，尽量保证按需加载时的体验。[在 webpack 中应用预加载](https://medium.com/webpack/link-rel-prefetch-preload-in-webpack-51a52358f84c)[4]非常简单，只需要在 dynamic import 中添加相应注释，webpack 就会知道你需要对这个 chunk 进行预加载。

```javascript
// prefetch
import(/* webpackPrefetch: true */ './sub1.js');

// preload
import(/* webpackPreload: true */ './sub2.js')
```

#### 1.2. 基于 JavaScript 的预加载

上面提到了基于 Resource Hints 的预加载技术，它其实像是一种声明式技术：你提出你的预加载需求，浏览器根据自身状态，选择合适的时候预加载。

如果你在[不兼容 Resource Hints](https://caniuse.com/#search=resource hint) 的浏览器上进行预加载，或者希望有“更强硬的”预加载控制，你可能会希望使用一些 JavaScript 中的功能来“巧妙”地进行预加载。

例如对于图片，

```javascript
let img = new Image();
img.src = '/static/img/prefetch.jpg';
```

上面的方法会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。

对于 JavaScript 和 CSS 可以动态添加 `<script>` 和 `<link>` 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）。

如果你希望通过 JavaScript 来进行预加载，可以使用 [PreloadJS](https://github.com/CreateJS/PreloadJS) 这个库，它提供了包括脚本、样式、图片、字体、SVG等[各类资源的预加载器](https://github.com/CreateJS/PreloadJS/tree/master/src/preloadjs/loaders)。

### 2. 视频预加载

视频预加载技术可以有效提高视频播放的用户体验。在 [Fast Playback with Video Preload](https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload)[5] 中提到了三种视频预加载方式。

#### 2.1. 为视频添加 `preload` 属性

使用 `preload` 属性可以让浏览器预加载相应的内容。其取值与作用如下表所示：

| 值   | 作用                               |
| ---- | ---------------------------------- |
| none | 不载入视频（即不预加载）           |
| meta | 载入元数据（时长、尺寸、文字轨道） |
| auto | 加载整个视频                       |

此外，你还可以设置 `poster` 属性，它规定视频下载时或用户点击播放按钮前播放器上显示的图像。一种推荐的方式是设置 `poster` 与 `preload: meta`，为用户提供一定的播放预览信息的同时避免过多的预加载流量。

#### 2.2. 使用 Preload Link

这一点已经在第一部分提到了，可以使用

```html
<link rel="preload" as="video" href="/static/sample.mp4">
```

进行资源的预加载。

#### 2.3. 使用 JavaScript 进行自定义的 Buffer 操作

可以通过 [HTTP `Range` 请求头](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)来获取开始的一小段视频数据，然后使用 [`MediaSource`](https://developer.mozilla.org/en-US/docs/Web/API/MediaSource) API 来进行视频媒体数据的暂存与播放。

下面这段示例代码摘自 [Fast Playback with Video Preload - Manual buffering](https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload#manual_buffering)，它可以实现视频数据的预加载，更多相关实现可以参见其中内容。

```html
<video id="video" controls></video>

<script>
    const mediaSource = new MediaSource();
    video.src = URL.createObjectURL(mediaSource);
    mediaSource.addEventListener('sourceopen', sourceOpen, { once: true });

    function sourceOpen() {
        URL.revokeObjectURL(video.src);
        const sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp09.00.10.08"');

        // Fetch beginning of the video by setting the Range HTTP request header.
        fetch('file.webm', { headers: { range: 'bytes=0-567139' } })
            .then(response => response.arrayBuffer())
            .then(data => {
                sourceBuffer.appendBuffer(data);
                sourceBuffer.addEventListener('updateend', updateEnd, { once: true });
            });
    }

    function updateEnd() {
        // Video is now ready to play!
        var bufferedSeconds = video.buffered.end(0) - video.buffered.start(0);
        console.log(bufferedSeconds + ' seconds of video are ready to play!');

        // Fetch the next segment of video when user starts playing the video.
        video.addEventListener('playing', fetchNextSegment, { once: true });
    }

    function fetchNextSegment() {
        fetch('file.webm', { headers: { range: 'bytes=567140-1196488' } })
            .then(response => response.arrayBuffer())
            .then(data => {
                const sourceBuffer = mediaSource.sourceBuffers[0];
                sourceBuffer.appendBuffer(data);
                // TODO: Fetch further segment and append it.
            });
    }
</script>
```

### 3. 预加载的策略

预加载一般都会面临一些矛盾：

- 预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；
- 预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。

设计一个高效的预加载策略是一个很复杂的问题 ，这里只简单介绍一些工具。

#### 3.1. quicklink

[quicklink](https://github.com/GoogleChromeLabs/quicklink) 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式。它的策略其实非常直接，核心就是当链接进入到视口后，会对其进行预加载。

当然我们还可以加一些其他策略，例如设定一个 200ms 的停留阈值。总体而言，它的策略还是比较简单的，更像是为前端预加载提供一个思路。如果感兴趣，可以从这篇文章中了解 [quicklink 的实现细节](https://juejin.im/post/5c21f8435188256d12597789)[6]。

#### 3.2. Guess.js

[Guess.js](https://github.com/guess-js/guess) 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。同时，在预加载之外，它还可以帮助实现最优的打包方式、加载路径等。核心就是通过大量的实际用户数据，来帮助前端性能优化做决策与预测。

你可以查看 [Guess.js Repo](https://github.com/guess-js/guess) 来进一步了解它，或者阅读[这篇介绍文章](https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/)[7]。

------

关于预加载的话题就到这了，我们的「前端性能优化之旅」也接近尾声了。最后一站，让我们再回来从整体维度聊聊前端性能优化吧。

## 尾声

我们这次的「前端性能优化之旅」已经到了尾声，还记得我们这次旅程的初衷么 —— 从整个前端访问链条的角度，来理解与掌握前端性能优化的知识和技术。

最后，再和大家聊一聊性能优化实践相关的话题。

### 1. 性能指标

Web 发展到现今阶段，性能指标已经不再只是 `DOMContentLoad` 和 `load` 这样的“面向浏览器”的指标，更多的会是以用户为中心（user-centric）的指标，例如：

- FP (First Paint)
- FID (First Input Delay)
- FCP (First Contentful Paint)
- FMP (First Meaningful Paint)
- TTI (Time to interactive)
- ……

所以在性能优化之前最重要的还是明确你的监控指标和分析维度，关于性能指标其实也是一个可以继续聊下去的内容，这里就不展开了，以后有机会希望把这部分也补充进来。

### 2. 持续优化

性能优化很多时候不是一蹴而就的，更不是一锤子买卖。一个良好的性能优化方案一定是一个持续循环的体系。

![circle](https://alienzhou.com/projects/fe-performance-journey/assets/img/circle.a09482ae.svg)

一个合理的性能优化方案，一定是通过线上的性能监控数据，或者前端自动化性能测试分析，发现性能问题，针对发现的问题进行分析与定位，然后进行对应的性能优化，最后上线观察。之后又会进入到下一个性能优化的循环中。所以推行性能优化，一定要注重优化工程的可持续性。

### 3. 监控与测试 💻

性能监控与测试也是一块非常大的话题，包括监控的手段、分析的维度等等，如果后续有机会希望把这块再补充上来。这里先介绍一下。

我们一般会把[性能数据分为两种](https://developers.google.com/web/fundamentals/performance/speed-tools/)[1]：

- 一种叫 Lab data，主要是在开发和测试人员本地或内部测试机器上跑出来的数据，例如在 CI/CD 中加入 [lighthouse](https://github.com/GoogleChrome/lighthouse)。它的优点在于采集的指标更全面，也易于复现问题；缺点主要在于有时候可能不能反应真实的用户体验情况。
- 另一种叫 Field data，也被成为 RUM (Real User Monitoring)，是指采集线上实际的性能数据来进行监控。它的优点则是能更好地发现用户实际遇到的性能问题；缺点主要是比较难以调试与复现问题，同时采集到的指标的详细程度不及 Lab data。

而 [The Three Types of Performance Testing](https://csswizardry.com/2018/10/three-types-of-performance-testing/)[2] 则进一步划分出了三类性能测试。

- 第一种叫做 Proactive：它可以理解为是工程师在开发阶段，通过浏览器调试等本地工具来发现并解决性能问题（善于利用 [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)[3] 也是一个优秀前端工程师所需要具备的 😊）；
- 第二种叫做 Reactive：它是一种自动化的性能测试，可以集成到自动化测试或流水线的其他阶段，会在构建与每次发布前执行；
- 第三种叫做 Passive：它就是在产品发布后，通过收集线上数据（或用户反馈）来发现性能问题，主要是基于一些 RUM。

选择哪种性能测试呢？答案是将它们结合使用（就像是自动化测试会结合单元测试、集成测试与端到端测试）。

对于一些易于标准化的性能标准，可以考虑使用 Proactive 和 Reactive 这样的 Lab data 来避免性能问题；而对于更复杂的业务场景，则可以通过 Passive 模式下的 Field data 进行监控。

### 4. 自动化 🛠

在性能优化上，请务必将可以自动化的工作都自动化。

前端性能优化的链路包括了「缓存 -> 发送请求 -> 等待响应 -> 解析 -> 处理各类静态资源 -> 运行时 -> 预加载（等待后续的请求）」，还是比较复杂的。因此，建议通过一些工具来将工作自动化。否则很可能无法保证性能优化的持续实施，因为它从来不是一锤子买卖。

在旅程中的各个技术点上，我也都会提到一些帮助快速实现优化或自动化的工具，例如 Workbox 提供的各类缓存方案、图片压缩的工具、webpack 插件等。还包括上面提到的，可以在 CI/CD 中集成的 [lighthouse](https://github.com/GoogleChrome/lighthouse)[4] 这样的分析工具。而对于 RUM，如果你们公司有人力可以自建一套体系，如果自建成本较高，可以考虑接入一些免费或收费的商业公司产品。
